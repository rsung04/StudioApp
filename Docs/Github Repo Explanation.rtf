{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red144\green144\blue144;\red22\green30\blue46;\red223\green225\blue230;
}
{\*\expandedcolortbl;;\cssrgb\c63137\c63137\c63137;\cssrgb\c11373\c16078\c23922;\cssrgb\c89804\c90588\c92157;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww11820\viewh8700\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 # Tutorial: StudioApp\
\
This project, `StudioApp`, acts like a **scheduling manager** for a dance studio.\
It uses a **two-stage approach** to create a timetable: first, it schedules *high-priority, longer blocks* for specific instructors (Stage A), which become **locked blocks**.\
Then, it uses these **locked blocks** as fixed obstacles and schedules *all the regular classes* (Stage B) around them, respecting **instructor** and **studio availability**.\
The core scheduling logic relies on the powerful **OR-Tools CP-SAT solver**, operating on a grid of **time slots**.\
\
\
## Visual Overview\
\
```mermaid\
flowchart TD\
    A0["DanceTimetableSolver\
"]\
    A1["Time Slots\
"]\
    A2["Studios (Rooms)\
"]\
    A3["Instructors\
"]\
    A4["Availability\
"]\
    A5["Priority Requests (Stage A)\
"]\
    A6["Locked Blocks\
"]\
    A7["Class Requests (Stage B)\
"]\
    A8["Two-Stage Solving\
"]\
    A9["OR-Tools CP-SAT Solver\
"]\
    A0 -- "Implements strategy" --> A8\
    A8 -- "Utilizes solver engine" --> A9\
    A0 -- "Loads input for Stage A" --> A5\
    A0 -- "Loads input for Stage B" --> A7\
    A0 -- "Loads constraints" --> A4\
    A0 -- "Loads resources" --> A2\
    A0 -- "Loads resources" --> A3\
    A0 -- "Uses time grid" --> A1\
    A8 -- "Stage A produces" --> A6\
    A6 -- "Consumed by Stage B" --> A8\
```\
\
## Chapters\
\
1. [Time Slots\
](01_time_slots_.md)\
2. [Studios (Rooms)\
](02_studios__rooms__.md)\
3. [Instructors\
](03_instructors_.md)\
4. [Priority Requests (Stage A)\
](04_priority_requests__stage_a__.md)\
5. [Class Requests (Stage B)\
](05_class_requests__stage_b__.md)\
6. [Availability\
](06_availability_.md)\
7. [Two-Stage Solving\
](07_two_stage_solving_.md)\
8. [Locked Blocks\
](08_locked_blocks_.md)\
9. [DanceTimetableSolver\
](09_dancetimetablesolver_.md)\
10. [OR-Tools CP-SAT Solver\
](10_or_tools_cp_sat_solver_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub>\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 # Chapter 1: Time Slots\
\
Welcome to the StudioApp tutorial! This first chapter introduces a foundational concept that the entire scheduling system relies on: **Time Slots**. Think of Time Slots as the fundamental building blocks of time within our application.\
\
## The Problem: Scheduling Activities\
\
Imagine you run a busy dance studio. You have different rooms, instructors, and classes, and you need to create a weekly timetable. You have activities like:\
\
*   A 60-minute Beginner Pole class.\
*   A 90-minute Open Heels session.\
*   An instructor needing a 3-hour practice block.\
\
How do you fit all these different durations neatly into a week without overlaps and ensuring everything starts and ends at sensible times? Trying to work with arbitrary minutes or seconds becomes messy quickly.\
\
## The Solution: The Time Slot Grid\
\
StudioApp solves this by imposing a consistent grid over the entire week. This grid is made up of small, equal-sized intervals called **Time Slots**.\
\
Think of it like drawing a grid on a large calendar poster. Once the grid is drawn, you can only place events so they perfectly align with the lines of the grid \'96 they must start exactly on a grid line and end exactly on another grid line.\
\
In StudioApp, the size of this grid square is defined by the `slotMinutes` setting.\
\
```json\
\{\
  "slotMinutes": 5,\
  "defaultClassDurationHours": 1,\
  ...\
\}\
```\
*A snippet from `assumptions.json`*\
\
This snippet tells us that each Time Slot in this configuration represents **5 minutes**.\
\
## Why Use Time Slots?\
\
Using a fixed, small time unit like 5 minutes provides several key benefits:\
\
1.  **Simplifies Calculations:** Instead of dealing with minutes or hours and potential fractional parts, everything is measured in whole numbers of "slots". A 60-minute class is exactly 12 slots (60 / 5 = 12). A 90-minute session is 18 slots (90 / 5 = 18).\
2.  **Ensures Alignment:** Activities can *only* start and end on a slot boundary. This prevents awkward timings (like a class starting at 17:03) and makes sure activities fit together perfectly end-to-end or with clean gaps.\
3.  **Common Unit:** Slots provide a single, consistent unit for representing duration, position, and availability across the entire week.\
\
## Activities and Slots: Start and Length\
\
Every activity we need to schedule \'96 whether it's a regular class or a special block \'96 is defined by two main things related to slots:\
\
*   `startSlot`: Which slot the activity begins at. This is an index counted from the very beginning of the scheduling week.\
*   `lengthSlots`: How many slots the activity lasts.\
\
Let's look at an example from the solver's output:\
\
```json\
[ \{\
  "instr" : "Ava",\
  "studioId" : "A",\
  "startSlot" : 228,\
  "lengthSlots" : 36\
\}, \{\
  "instr" : "Liam",\
  "studioId" : "A",\
  "startSlot" : 288,\
  "lengthSlots" : 24\
\} ]\
```\
*A snippet from `target/classes/sample_data/solverA.json`*\
\
This JSON shows two scheduled activities. The first one, instructed by "Ava", starts at `startSlot` 228 and lasts for `lengthSlots` 36. Since each slot is 5 minutes, 36 slots is 36 * 5 = 180 minutes, which is 3 hours.\
\
The second activity, instructed by "Liam", starts at `startSlot` 288 and lasts for `lengthSlots` 24. 24 slots is 24 * 5 = 120 minutes, or 2 hours.\
\
Notice how everything is expressed using these slot numbers. The scheduling problem for the computer becomes: "Find a `startSlot` for each activity such that they fit within the studio's operating hours, don't overlap in the same studio or with the same instructor, and respect other rules, while making sure each activity has the correct `lengthSlots`."\
\
## Slots and Real Time\
\
While the solver works with abstract slot numbers, we (and the system for displaying a timetable) need to convert these slot numbers back into real-world days and times.\
\
The total number of slots in a week is determined by the studio's operating hours for each day, as defined in the `assumptions.json`:\
\
```json\
\{\
  "slotMinutes": 5,\
  "termWeeks": 1, // Let's assume a 1-week term for simplicity\
  "rooms": [\
    \{\
      "id": "room1",\
      "dailyOperatingHours": \{\
        "MONDAY":    \{ "startTime": "16:30", "endTime": "22:00" \},\
        "TUESDAY":   \{ "startTime": "16:30", "endTime": "22:00" \},\
        // ... other days ...\
        "SATURDAY":  \{ "startTime": "09:30", "endTime": "22:00" \},\
        // ... etc. ...\
      \}\
    \}\
    // ... other rooms ...\
  ],\
  ...\
\}\
```\
*A snippet from `assumptions.json` showing operating hours*\
\
The system calculates the total number of 5-minute slots available across the entire week based on these operating hours. Slot `0` corresponds to the *very first* available 5-minute interval on the first day (usually Monday morning or when the first studio opens), and the slot numbers increase sequentially throughout the week.\
\
## Converting Between Time and Slots (Behind the Scenes)\
\
The `DanceTimetableSolver.java` code contains logic to perform these conversions. It calculates a total sequence of slots and determines which range of slots corresponds to which day and time.\
\
For example, if Monday's operating hours are 16:30 to 22:00 (5.5 hours = 330 minutes), that's 330 / 5 = 66 slots. If Tuesday's are also 66 slots, then Wednesday's slots might start at slot index 132 (66 + 66).\
\
Here's a simplified look at how a time is converted into a slot index:\
\
```mermaid\
sequenceDiagram\
    participant User\
    participant StudioApp\
    participant SlotLogic\
\
    User->>StudioApp: Schedule class on Mon at 17:00?\
    StudioApp->>SlotLogic: Convert "Monday 17:00" to slot index\
    SlotLogic-->>SlotLogic: Find Monday's starting slot index\
    SlotLogic-->>SlotLogic: Calculate minutes from Monday's start (17:00 - 16:30 = 30 mins)\
    SlotLogic-->>SlotLogic: Convert minutes to slots (30 / 5 = 6 slots)\
    SlotLogic-->>SlotLogic: Add to Monday's start index (e.g., 0 + 6 = slot 6)\
    SlotLogic-->>StudioApp: Returns: slot index 6\
    StudioApp-->>User: Yes, available from slot 6 (17:00)!\
```\
\
Similarly, the `slotToDate` function in the code does the reverse: given a slot number, it figures out which day and time that slot corresponds to.\
\
```java\
// From DanceTimetableSolver.java\
\
private static final int SLOT_MIN = 5; // The size of one slot in minutes\
private static final int DUR60   = 60 / SLOT_MIN; // How many slots are in 60 minutes (12 for 5-min slots)\
\
// Logic to calculate total slots and day prefixes happens internally\
// ...\
private static final int TOTAL_SLOTS = ...; // Total number of slots in the week\
\
// Simplified concept of converting time to slot\
private static int toSlot(DayOfWeek d,LocalTime t)\{\
    // Find the starting slot index for day 'd'\
    int dayStartSlot = prefix.get(d); // Example: prefix.get(MONDAY) might be 0\
    // Find the start time for operating hours on day 'd'\
    DaySpan daySpan = DAY_WINDOWS.get(d); // Example: Monday 16:30\
    // Calculate minutes difference from day's start time to 't'\
    long minutesFromStart = daySpan.start.until(t, ChronoUnit.MINUTES); // Example: 17:00 - 16:30 = 30 mins\
    // Convert minutes difference to slots\
    int slotsFromStart = (int)(minutesFromStart / SLOT_MIN); // Example: 30 / 5 = 6 slots\
    // Total slot index is day's start + offset from start\
    return dayStartSlot + slotsFromStart; // Example: 0 + 6 = 6\
\}\
\
// Simplified concept of converting slot to time\
private static LocalDateTime slotToDate(long slot)\{\
    // Find which day the slot falls into using the prefixes\
    DayOfWeek day = findDayForSlot(slot); // Internal logic using prefix map\
    // Calculate the offset of the slot within that day's operating hours\
    int offsetInDay = (int)(slot - prefix.get(day));\
    // Find the start time of that day's operating hours\
    LocalTime dayStartTime = DAY_WINDOWS.get(day).start; // Example: Monday 16:30\
    // Calculate the real time: day's start time + (offsetInDay * SLOT_MIN) minutes\
    LocalTime slotTime = dayStartTime.plusMinutes(offsetInDay * SLOT_MIN); // Example: 16:30 + (6 * 5) minutes = 16:30 + 30 minutes = 17:00\
    // Combine with a reference date for a full LocalDateTime (used for printing)\
    return LocalDateTime.of(2025,6,2,0,0).plusDays(day.getValue()-1).with(slotTime);\
\}\
```\
*Simplified concepts from `DanceTimetableSolver.java`*\
\
The solver primarily uses the integer slot indices (`startSlot`, `lengthSlots`) because they are much easier to work with mathematically when figuring out overlaps and placement constraints. The conversion to and from real-world times happens mainly for input (like reading availability times) and output (like printing the final schedule).\
\
## Conclusion\
\
In this chapter, we learned that **Time Slots** are the fundamental units of time in StudioApp's scheduling system. They provide a consistent, discrete grid that simplifies the complex problem of scheduling. All activities, regardless of their real-world duration, are represented by a `startSlot` and `lengthSlots`, allowing the solver to work efficiently with integer values.\
\
In the next chapter, we'll look at where these scheduled activities actually take place: the [Studios (Rooms)](02_studios__rooms__.md).\
\
[Studios (Rooms)](02_studios__rooms__.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/assumptions.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/solverA.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/assumptions.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/solverA.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 2: Studios (Rooms)\
\
Welcome back to the StudioApp tutorial! In the [previous chapter](01_time_slots_.md), we learned about the fundamental building blocks of our schedule: [Time Slots](01_time_slots_.md). We saw how everything, from a 5-minute interval to a multi-hour class, is measured and represented using these consistent units.\
\
Now that we understand *when* things can happen, let's think about *where* they happen. This brings us to the concept of **Studios (Rooms)**.\
\
## The Problem: Where Do Activities Happen?\
\
Imagine our dance studio again. We don't just have a list of classes; we have physical rooms where these classes take place.\
\
*   The "Front Room" might be bigger and better for certain types of dance.\
*   The "Back Room" might be smaller or have different equipment.\
\
When scheduling, we need to assign each activity (whether it's a class or an instructor's practice block) to a specific room. And there are critical rules we must follow:\
\
1.  You can't schedule two different activities in the *same* room at the *exact same time*. That would cause a physical collision!\
2.  Each room might only be available during certain hours of the day or week. You can't schedule a late-night class if the building is locked.\
\
Trying to manually juggle all the activities, rooms, and time slots can quickly become a headache, especially with many classes and rooms.\
\
## The Solution: Modeling Studios\
\
StudioApp solves this by representing each physical room as a **Studio** object in the system. Each Studio has key information that the scheduler needs to respect.\
\
Think of each Studio as a container for activities. An activity (like a class) needs to be placed *inside* a specific Studio for a specific duration of [Time Slots](01_time_slots_.md).\
\
The crucial rules mentioned above are built directly into how we model and use Studios:\
\
*   **Constraint 1 (No Overlap):** For any given Studio, no two scheduled activities (like classes or blocks) can occupy the same [Time Slots](01_time_slots_.md).\
*   **Constraint 2 (Operating Hours):** An activity can only be scheduled in a Studio during that Studio's defined operating hours. These operating hours are defined in terms of which [Time Slots](01_time_slots_.md) are available for that specific room on each day of the week.\
\
## What Defines a Studio?\
\
In StudioApp, each Studio is defined by a few key properties:\
\
| Property              | Description                                                                 | Example Value(s)           |\
| :-------------------- | :-------------------------------------------------------------------------- | :------------------------- |\
| `id`                  | A unique identifier for the studio (used internally by the solver).       | `"room1"`, `"studioA"`     |\
| `name`                | A human-readable name for the studio.                                       | `"Front Room"`, `"Yoga Studio"` |\
| `dailyOperatingHours` | Specifies when the studio is available on each day of the week. This is key!| See JSON example below.    |\
| `capacity` (Optional) | The maximum number of people the room can hold. (Less critical for core time scheduling, but useful). | `30`                     |\
\
Let's look at how this is represented in the `assumptions.json` file:\
\
```json\
\{\
  "slotMinutes": 5,\
  // ... other settings ...\
  "rooms": [\
    \{\
      "id": "room1",\
      "name": "Front Room",\
      "capacity": 30,\
      "dailyOperatingHours": \{\
        "MONDAY":    \{ "startTime": "16:30", "endTime": "22:00" \},\
        "TUESDAY":   \{ "startTime": "16:30", "endTime": "22:00" \},\
        // ... other weekdays ...\
        "SATURDAY":  \{ "startTime": "09:30", "endTime": "22:00" \},\
        "SUNDAY":    \{ "startTime": "09:30", "endTime": "22:00" \}\
      \}\
    \},\
    \{\
      "id": "room2",\
      "name": "Back Room",\
      "capacity": 20,\
      "dailyOperatingHours": \{\
        "MONDAY":    \{ "startTime": "16:30", "endTime": "22:00" \},\
        "TUESDAY":   \{ "startTime": "16:30", "endTime": "22:00" \},\
        // ... same hours as room1 in this example ...\
      \}\
    \}\
  ],\
  // ... other data ...\
\}\
```\
*A snippet from `assumptions.json` showing the `rooms` definition*\
\
This snippet defines two studios: "room1" and "room2". Notice how `dailyOperatingHours` specifies the available time range for each day. The scheduler uses these times, combined with the `slotMinutes` setting, to determine the *specific [Time Slots](01_time_slots_.md)* during which activities can be placed in that studio on that day.\
\
For example, for "room1" on Monday (16:30 to 22:00, which is 5.5 hours or 330 minutes), if `slotMinutes` is 5, this corresponds to 330 / 5 = 66 available [Time Slots](01_time_slots_.md) on that day. These 66 slots form a continuous block of time *specific to room1* on Monday within the overall weekly sequence of slots.\
\
## The Studio Constraint: No Overlap!\
\
This is arguably the most important rule associated with Studios for scheduling. It's simple in concept but crucial for creating a valid timetable: **A Studio can only host one activity at any given time slot.**\
\
Think of it like booking meeting rooms in an office. If "Meeting Room A" is booked from 10:00 to 11:00, you cannot book another meeting in "Meeting Room A" during that same 10:00-11:00 window. You have to find a different room or a different time.\
\
The solver needs to understand this rule for *each* studio defined in the system.\
\
Let's visualize this simple rule:\
\
```mermaid\
sequenceDiagram\
    participant ActivityA\
    participant ActivityB\
    participant Studio1\
    participant Solver\
\
    ActivityA->>Solver: Request to schedule at Slot 100 in Studio1\
    ActivityB->>Solver: Request to schedule at Slot 100 in Studio1\
    Solver->>Studio1: Check availability at Slot 100\
    Note over Studio1: Studio1 is now occupied by ActivityA at Slot 100\
    Studio1-->>Solver: Reports: Occupied by ActivityA!\
    Solver-->>ActivityB: Cannot schedule ActivityB at Slot 100 in Studio1. Must find another slot or studio.\
```\
\
This diagram simplifies the process, but the core idea is that the solver sees requests for [Time Slots](01_time_slots_.md) in specific Studios and must ensure that no two requests for the *same* Studio overlap in time.\
\
## How the Solver Handles the Studio Constraint\
\
The OR-Tools CP-SAT solver has a powerful built-in feature specifically for handling this kind of "no overlap" requirement over time intervals. It's called, unsurprisingly, the `NoOverlap` constraint.\
\
In our `DanceTimetableSolver.java` code, after setting up all the activities (which are represented as potential intervals in [Time Slots](01_time_slots_.md)), we group these activities by the Studio they are assigned to.\
\
We use a map (`byStudio`) to keep track of which potential scheduled intervals belong to which Studio:\
\
```java\
// From DanceTimetableSolver.java (Simplified)\
Map<Studio,List<IntervalVar>> byStudio=new HashMap<>();\
\
// ... inside the loops where activities (classes or blocks) are processed ...\
\
// For each activity, create an IntervalVar (representing its potential time span)\
IntervalVar iv = m.newOptionalIntervalVar(...); // or m.newFixedInterval(...) for locked blocks\
\
// Add this interval to the list for the activity's assigned studio\
byStudio.computeIfAbsent(activity.studio, k -> new ArrayList<>()).add(iv);\
\
// ... continue for all activities ...\
```\
*Simplified code showing intervals grouped by Studio*\
\
After all activities are added to this map, we add the `NoOverlap` constraint for each list of intervals associated with a Studio:\
\
```java\
// From DanceTimetableSolver.java (Simplified)\
\
// Apply the NoOverlap constraint to each studio's list of intervals\
byStudio.values().forEach(m::addNoOverlap);\
```\
*Simplified code applying the NoOverlap constraint*\
\
This `m.addNoOverlap(list)` call tells the solver: "Look at all the time intervals in this `list` (which belong to a single studio). You must find a schedule such that *no two* intervals in this list are active at the same time."\
\
This is how the simple rule "one activity per room at a time" is translated into a mathematical constraint that the solver understands and enforces.\
\
The solver also automatically respects the `dailyOperatingHours` because the initial range of possible `startSlot` values for any activity placed in a studio is limited to the [Time Slots](01_time_slots_.md) available for that studio according to its daily hours. An activity of `lengthSlots` can only start at a `startSlot` if all `lengthSlots` after it also fall within the studio's operating hours.\
\
## Conclusion\
\
Studios (Rooms) are the physical locations essential for scheduling activities. They introduce two critical constraints: activities must stay within a studio's operating hours, and no two activities can occupy the same studio at the same time. By defining studios with their IDs, names, and operating hours, and by applying the `NoOverlap` constraint in the solver for each studio, StudioApp ensures that the resulting timetable is physically possible and avoids room conflicts.\
\
In the next chapter, we'll look at the third essential component for scheduling: the [Instructors](03_instructors_.md) who teach the classes and require practice time.\
\
[Instructors](03_instructors_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/assumptions.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/solverA.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/assumptions.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/solverA.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 3: Instructors\
\
Welcome back to the StudioApp tutorial! In the previous chapters, we've laid the groundwork for our scheduling system. We learned about [Time Slots](01_time_slots_.md) as the fundamental grid for scheduling *when* things happen, and [Studios (Rooms)](02_studios__rooms__.md) as the physical locations for *where* activities take place, ensuring no two activities collide in the same room at the same time.\
\
Now, let's introduce the third essential piece: **Instructors**.\
\
## The Problem: Who Teaches the Classes?\
\
Every class needs a teacher, and instructors aren't just abstract names \'96 they are real people! Like studios, instructors introduce their own set of scheduling challenges:\
\
1.  **One Person, One Place:** An instructor, just like a studio, can only be in one place doing one thing at any given moment. You can't schedule "Ava" to teach a class in Studio A at 6:00 PM and also teach another class in Studio B at 6:00 PM.\
2.  **Limited Availability:** Instructors aren't available all the time. They have personal lives, other jobs, or specific times they prefer or are only able to work. A timetable must respect these personal "free" or "busy" periods.\
\
Simply put, we need to make sure that the schedule works not only for the rooms but also for the people leading the activities.\
\
## The Solution: Modeling Instructors\
\
StudioApp models each teacher or person who leads an activity as an **Instructor**. Each Instructor object represents that unique individual and carries information crucial for scheduling, specifically their availability.\
\
Think of each Instructor as having their own personal calendar that the scheduler needs to respect. An activity assigned to an Instructor must be placed within the times marked "Available" on *their* calendar.\
\
The key rules for Instructors are:\
\
*   **Constraint 1 (No Overlap):** For any given Instructor, no two scheduled activities can occupy the same [Time Slots](01_time_slots_.md).\
*   **Constraint 2 (Availability):** An activity can only be scheduled for an Instructor during one of their defined availability windows.\
\
## What Defines an Instructor (for Scheduling)?\
\
For the purpose of scheduling, the primary information we need about an instructor is their identity and their availability:\
\
| Property   | Description                                                                                                | Example Value(s)            |\
| :--------- | :--------------------------------------------------------------------------------------------------------- | :-------------------------- |\
| `name`     | A unique identifier (like a name or ID) for the instructor.                                                | `"Ava"`, `"Liam"`           |\
| `windows`  | A list of specific time ranges (days and times) when the instructor is available to be scheduled for work. | See JSON example below.     |\
\
Let's look at how instructor data is represented in the sample `availability.json` file:\
\
```json\
[\
  \{"instructor":"Ava","day":"MONDAY","start":"17:00","end":"21:00"\},\
  \{"instructor":"Ava","day":"THURSDAY","start":"18:00","end":"22:00"\},\
  \{"instructor":"Liam","day":"TUESDAY","start":"16:00","end":"20:00"\},\
  // ... more instructors and availability windows ...\
]\
```\
*A snippet from `availability.json` showing instructor availability*\
\
This snippet shows that "Ava" is available on Monday from 17:00 to 21:00 and on Thursday from 18:00 to 22:00. "Liam" is available on Tuesday from 16:00 to 20:00. These times, combined with the `slotMinutes` setting (e.g., 5 minutes), define the specific range of [Time Slots](01_time_slots_.md) during which activities can be scheduled for that instructor.\
\
For example, if Monday starts counting slots at 16:30 (from Studio operating hours) and `slotMinutes` is 5:\
*   17:00 is 30 minutes (6 slots) after 16:30.\
*   21:00 is 4 hours (240 minutes, 48 slots) after 17:00, or 4 hours 30 minutes (270 minutes, 54 slots) after 16:30.\
*   So, Ava's Monday window is a block of 48 slots starting at the slot corresponding to 17:00 on Monday. Any activity for Ava on Monday must start and end *within* this 48-slot window.\
\
Instructors are also linked to the specific classes they can teach, as seen in `classesByInstructor.json`:\
\
```json\
\{\
  "classesByInstructor": \{\
    "Ava": [\
      "intro_to_basework",\
      "inter_2_aerial_tricks",\
      "bend_it_like_mucci"\
    ],\
    "Liam": [\
      "adv_xo_pole_choreo",\
      "elementary_aerial_tricks"\
    ],\
    // ... more instructors and their class IDs ...\
  \}\
\}\
```\
*A snippet from `classesByInstructor.json` linking instructors to classes*\
\
And instructors might also request specific priority time blocks for practice or other work, as seen in `InstructorPriority.json`:\
\
```json\
[\
  \{ "instructor": "Ava",      "priority": 1, "blockLengthHours": 3 \},\
  \{ "instructor": "Liam",     "priority": 2, "blockLengthHours": 2 \},\
  // ... more instructors and their priority requests ...\
]\
```\
*A snippet from `InstructorPriority.json` showing instructor priority requests*\
\
All these pieces of data tell the system *which* activities are associated with *which* instructor.\
\
## The Instructor Constraint: No Overlap!\
\
This is the core rule for instructors in the solver: **An Instructor can only be assigned to one activity at any given time slot.**\
\
It's the exact same rule we saw for [Studios (Rooms)](02_studios__rooms__.md), but applied from a different perspective \'96 the person's perspective. If Instructor "Ava" is teaching a class from Slot 100 to Slot 110, she cannot be doing anything else (teaching another class, having a priority practice block) from Slot 100 to Slot 110.\
\
Let's visualize this with a simple diagram for one instructor:\
\
```mermaid\
sequenceDiagram\
    participant ActivityX\
    participant ActivityY\
    participant InstructorA\
    participant Solver\
\
    ActivityX->>Solver: Request to schedule at Slot 250 for InstructorA\
    ActivityY->>Solver: Request to schedule at Slot 250 for InstructorA\
    Solver->>InstructorA: Check availability at Slot 250\
    Note over InstructorA: InstructorA is now occupied by ActivityX at Slot 250\
    InstructorA-->>Solver: Reports: Occupied by ActivityX!\
    Solver-->>ActivityY: Cannot schedule ActivityY at Slot 250 for InstructorA. Must find another slot or instructor.\
```\
\
Just like with studios, the solver needs to understand and enforce this "no overlap" rule for *each individual instructor* defined in the system.\
\
The solver also needs to ensure that the activity is placed within the specific `Availability` windows defined for that instructor. An activity starting at `startSlot` with `lengthSlots` must fit entirely inside one of the instructor's available time blocks for that week.\
\
## How the Solver Handles Instructor Constraints\
\
The OR-Tools CP-SAT solver uses the same powerful `NoOverlap` constraint we saw with studios, but applies it to groups of activities associated with the same instructor.\
\
In `DanceTimetableSolver.java`, after loading all the data, activities (both priority blocks and regular classes) are associated with an `Instructor` object.\
\
When setting up the model, the solver groups all potential time intervals (represented by `IntervalVar` objects) by the instructor they require. A map (`byInstr`) is used for this:\
\
```java\
// From DanceTimetableSolver.java (Simplified)\
Map<Instructor,List<IntervalVar>> byInstr=new HashMap<>();\
\
// ... inside the loops where activities (classes or blocks) are processed ...\
\
// For each activity (class or block) create an IntervalVar\
IntervalVar iv = m.newOptionalIntervalVar(...); // or m.newFixedInterval(...)\
\
// Add this interval to the list for the activity's assigned instructor\
byInstr.computeIfAbsent(activity.instr, k -> new ArrayList<>()).add(iv);\
\
// ... continue for all activities ...\
```\
*Simplified code showing intervals grouped by Instructor*\
\
After all activities are added, the `NoOverlap` constraint is applied to the list of intervals for each instructor:\
\
```java\
// From DanceTimetableSolver.java (Simplified)\
\
// Apply the NoOverlap constraint to each instructor's list of intervals\
byInstr.values().forEach(m::addNoOverlap);\
```\
*Simplified code applying the NoOverlap constraint per instructor*\
\
This `m.addNoOverlap(list)` call tells the solver: "Look at all the time intervals in this `list` (which belong to a single instructor). You must find a schedule such that *no two* intervals in this list are active at the same time."\
\
Additionally, the solver needs to enforce the *availability windows*. For each potential scheduled activity, a constraint is added that forces the activity's `startSlot` and `lengthSlots` to fit within one of the instructor's available `windows`. If the activity is marked as "present" (scheduled), it *must* be contained within one of the valid time slots defined by their availability.\
\
```java\
// From DanceTimetableSolver.java (Simplified concept)\
private static void addWindowConstraints(CpModel m, IntVar start, int lenSlots, List<Availability> windows, BoolVar lit)\{\
    List<Literal> optionals=new ArrayList<>();\
    for(Availability av:windows)\{\
        // Convert availability time window (start, end) to slot indices (ws, we)\
        int ws=toSlot(av.day,av.from), we=toSlot(av.day,av.to);\
        // Create a boolean variable that is true if this window is used for the activity\
        BoolVar wlit=m.newBoolVar("win");\
        // If this window is used, the activity must start >= window start slot\
        m.addGreaterOrEqual(start,ws).onlyEnforceIf(wlit);\
        // If this window is used, the activity must end <= window end slot\
        // Activity ends at start + lengthSlots\
        m.addLessOrEqual(start,we-lenSlots).onlyEnforceIf(wlit);\
        // Collect this window's boolean literal\
        optionals.add(wlit);\
        // If this window is used (wlit is true), the activity must be present (lit must be true)\
        m.addImplication(wlit,lit);\
    \}\
    // If the activity is present (lit is true), *exactly one* of the availability windows must be used (one wlit must be true)\
    // We add lit.not() to the list of optionals. If lit is false (activity not present), then lit.not() is true,\
    // satisfying the exactly one constraint with zero wlit being true.\
    optionals.add(lit.not());\
    m.addExactlyOne(optionals);\
\}\
```\
*Simplified code showing how availability windows are constrained*\
\
This function is called for each activity (class or priority block), linking the activity's potential start time (`start`) and presence (`lit`) to the instructor's specific availability windows.\
\
By applying these two sets of constraints \'96 availability windows and per-instructor NoOverlap \'96 the solver ensures that the resulting schedule is valid from each instructor's perspective.\
\
## Conclusion\
\
Instructors are key entities in the scheduling problem, representing the people who lead activities. They introduce constraints based on their personal availability windows and the fundamental rule that one person cannot be in two places at once. StudioApp models instructors and their availability and uses the powerful `NoOverlap` constraint, combined with specific constraints for availability windows, to ensure the generated timetable is feasible for every instructor.\
\
Understanding Time Slots, Studios, and Instructors gives us the three fundamental dimensions of our scheduling problem: When, Where, and Who. In the next chapter, we will explore how these concepts are used in the first part of our two-stage solving process: [Priority Requests (Stage A)](04_priority_requests__stage_a__.md).\
\
[Priority Requests (Stage A)](04_priority_requests__stage_a__.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/InstructorPriority.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/availability.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/classesByInstructor.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/InstructorPriority.json), [[6]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/availability.json), [[7]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/classesByInstructor.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 4: Priority Requests (Stage A)\
\
Welcome back to the StudioApp tutorial! In our journey so far, we've established the fundamental concepts: [Time Slots](01_time_slots_.md) define *when* things can happen, [Studios (Rooms)](02_studios__rooms__.md) define *where* activities take place (and ensure no room is double-booked), and [Instructors](03_instructors_.md) define *who* is leading an activity (and ensure no instructor is double-booked, while respecting their availability).\
\
Now, we're going to introduce a special type of scheduling request and the first step in our timetable-solving process: **Priority Requests (Stage A)**.\
\
## The Problem: Handling Special Needs First\
\
Imagine you have a star instructor, let's call her Ava, who needs a dedicated, uninterrupted 3-hour block each week specifically for choreography practice or personal training. This isn't a regular class; it's a crucial block of time essential for her work and potentially the studio's success.\
\
If you just throw this 3-hour request into the mix with dozens of standard 1-hour classes, it might be difficult to find a suitable slot for the long block later. Longer blocks are harder to fit than shorter ones. To make sure these important requests don't get squeezed out, we need a way to give them preferential treatment.\
\
## The Solution: Prioritize and Place First\
\
StudioApp solves this by identifying certain scheduling requests as **Priority Requests**. These are typically blocks of time requested by specific instructors (like Ava's 3-hour practice block). The key is that these requests are handled in the **first stage** of the scheduling process.\
\
Think of it like booking appointments. If you have a VIP client needing a long, specific slot, you book *that* appointment first, before you start filling up the rest of your day with standard 15-minute slots.\
\
This "VIP treatment" is what we call **Stage A** of the solver. In Stage A, the solver focuses *only* on trying to fit these high-priority blocks into the timetable, respecting all the basic rules (fitting within [Time Slots](01_time_slots_.md), using an available [Studio (Room)](02_studios__rooms__.md), respecting the [Instructor](03_instructors_.md)'s availability, and avoiding overlaps with *other* priority requests).\
\
The goal of Stage A is to find the best possible placement for these critical blocks, or at least as many of them as possible.\
\
## What Defines a Priority Request?\
\
In StudioApp, a priority request is primarily defined by:\
\
| Property           | Description                                                                 | Example Value(s)        |\
| :----------------- | :-------------------------------------------------------------------------- | :---------------------- |\
| `instructor`       | The [Instructor](03_instructors_.md) making the request.                    | `Ava`, `Liam`           |\
| `blockLengthHours` | The required length of the continuous time block, in hours.                 | `3`, `2`, `1`           |\
| `priority`         | A numerical value indicating relative importance (lower number = higher priority). Note: In the sample, only blocks > 1 hour are currently treated as Stage A priority requests. | `1`, `2`, `3`           |\
\
These requests are typically read from a file like `InstructorPriority.json`:\
\
```json\
[\
  \{ "instructor": "Ava",      "priority": 1, "blockLengthHours": 3 \},\
  \{ "instructor": "Liam",     "priority": 2, "blockLengthHours": 2 \},\
  \{ "instructor": "Noah",     "priority": 3, "blockLengthHours": 1 \},\
  // ... more instructors and their priority requests ...\
]\
```\
*A snippet from `InstructorPriority.json`*\
\
In the current `DanceTimetableSolver.java` implementation, Stage A specifically focuses on requests with `blockLengthHours` greater than 1 hour from this file. Requests for 1-hour blocks (or standard classes) are handled in the next stage.\
\
## How Stage A Works\
\
Stage A is a dedicated pass of the solver focused *only* on the priority requests. Here's the simplified process:\
\
1.  **Load Requests:** Read the priority requests (like the ones from `InstructorPriority.json`).\
2.  **Represent as Options:** For each priority request, the solver creates a variable representing a potential block of time (`lengthSlots` derived from `blockLengthHours`) for the specified [Instructor](03_instructors_.md). Crucially, this block is marked as *optional*. The solver doesn't *have* to schedule it.\
3.  **Apply Constraints:**\
    *   Ensure each optional block, *if scheduled*, fits within the [Instructor](03_instructors_.md)'s [Availability](06_availability_.md) windows.\
    *   Ensure each optional block, *if scheduled*, fits within the operating hours of the [Studio (Room)](02_studios__rooms__.md) it's assigned to (or could potentially be assigned to).\
    *   Apply the `NoOverlap` constraint for *each* [Instructor](03_instructors_.md): no two *scheduled* optional blocks for the same instructor can overlap.\
    *   Apply the `NoOverlap` constraint for *each* [Studio (Room)](02_studios__rooms__.md): no two *scheduled* optional blocks in the same studio can overlap.\
4.  **Solve for Max Placement:** Tell the solver to find a schedule that places as many of these optional priority blocks as possible. (The specific objective in `DanceTimetableSolver` is currently to maximize the *number* of placed blocks).\
5.  **Confirm Placed Blocks:** After the solver finds a solution, identify which optional blocks were successfully placed (i.e., whose "presence" variable is true).\
6.  **Output/Cache:** These successfully placed blocks are now considered "locked" or confirmed. They are saved (e.g., to `solverA.json`) to be used as fixed requirements for Stage B.\
\
Here's a very simple look at the interaction during Stage A:\
\
```mermaid\
sequenceDiagram\
    participant PriorityRequest1\
    participant PriorityRequest2\
    participant SolverA\
    participant StudioConstraints\
    participant InstructorConstraints\
    participant AvailabilityConstraints\
\
    PriorityRequest1->>SolverA: Try to place me (3hr, InstructorA, StudioA)\
    PriorityRequest2->>SolverA: Try to place me (2hr, InstructorB, StudioB)\
\
    SolverA->>StudioConstraints: Check if StudioA/B has 3hr/2hr window without other blocks?\
    StudioConstraints-->>SolverA: Yes, StudioA available here, StudioB available there.\
    SolverA->>InstructorConstraints: Check if InstructorA/B are free at those times without other blocks?\
    InstructorConstraints-->>SolverA: Yes, InstructorA free here, InstructorB free there.\
    SolverA->>AvailabilityConstraints: Check if times are within InstructorA/B availability?\
    AvailabilityConstraints-->>SolverA: Yes, within Ava's window, Yes, within Liam's window.\
\
    Note over SolverA: Finds a valid placement for both\
\
    SolverA-->>PriorityRequest1: Success! Scheduled at Slot X.\
    SolverA-->>PriorityRequest2: Success! Scheduled at Slot Y.\
\
    Note over SolverA: Records placed blocks as "Locked"\
\
    SolverA-->>SolverA: Save "Locked" blocks for Stage B.\
```\
*(Note: The solver doesn't actually ask questions one by one like this; it considers all constraints simultaneously to find a solution. This diagram is a simplification to show the involved constraints.)*\
\
The outcome of Stage A is a list of concrete, scheduled time blocks that *must* be respected in any subsequent scheduling.\
\
## Code Implementation Notes (Simplified)\
\
Let's look at tiny snippets from `DanceTimetableSolver.java` that illustrate this process.\
\
First, loading the priority requests and filtering them for Stage A:\
\
```java\
// From DanceTimetableSolver.java (main method snippet)\
\
// ... load instructor data ...\
\
// Load instructor priorities\
List<Map<String, Object>> prJson;\
prJson = tryLoadList("InstructorPriority.json", "instructorPriority", ...);\
\
/* --- Filter: Stage\'a0A should schedule only blocks longer than 1\uc0\u8239 hour --- */\
PRIORITY = prJson.stream()\
        .filter(m -> ((Number) m.get("blockLengthHours")).intValue() > 1) // Keep > 1 hour\
        .sorted(Comparator.comparingInt(m -> ((Number) m.get("priority")).intValue())) // Sort by priority\
        .map(m -> new PriorityReq( // Convert to our internal object\
                instrMap.get((String) m.get("instructor")),\
                A,    // Still using Studio A for demo simplicity here\
                ((Number) m.get("blockLengthHours")).intValue()))\
        .toList();\
\
// Now call the Stage A solver function\
StageAResult stageA = solveStageA();\
List<LockedBlock> locked = stageA.locked; // Get the confirmed blocks\
saveLockedBlocks(locked, CACHE); // Save them for Stage B\
```\
*Simplified code loading and filtering priority requests for Stage A*\
\
This shows how the raw data is read, filtered based on length (greater than 1 hour for Stage A in this example), sorted by priority (though the current solver primarily maximizes *quantity* of placed blocks, sorting is good practice), and then converted into `PriorityReq` objects. The results of `solveStageA` are saved.\
\
Inside the `solveStageA` function, each `PriorityReq` is turned into an optional interval:\
\
```java\
// From DanceTimetableSolver.java (inside solveStageA)\
\
for(PriorityReq pr:PRIORITY)\{\
    int lenSlots = pr.hours * DUR60; // Convert hours to slots\
    IntVar start = m.newIntVar(0, TOTAL_SLOTS - lenSlots, "pstart" + pr.instr.name); // Variable for start slot\
    BoolVar present = m.newBoolVar("present" + pr.instr.name); // Boolean: is this block scheduled?\
    IntVar end = m.newIntVar(0, TOTAL_SLOTS, "pend" + pr.instr.name);\
\
    // Link start, length, end, and presence using addEquality.\
    // This means 'end = start + lenSlots' is only required IF 'present' is true.\
    m.addEquality(LinearExpr.sum(new LinearArgument[]\{start, m.newConstant(lenSlots)\}), end).onlyEnforceIf(present);\
\
    // Create an optional interval for this block\
    IntervalVar iv = m.newOptionalIntervalVar(start, m.newConstant(lenSlots), end, present, "iv_p_" + pr.instr.name);\
\
    // Group intervals by instructor and studio for NoOverlap constraints\
    byInstr.computeIfAbsent(pr.instr, k -> new ArrayList<>()).add(iv);\
    byStudio.computeIfAbsent(pr.studio, k -> new ArrayList<>()).add(iv);\
\
    // Add constraints to ensure placement is within instructor's availability windows IF present\
    addWindowConstraints(m, start, lenSlots, pr.instr.windows, present);\
\
    presences.add(present); // Keep track of all presence variables\
\}\
\
// Apply NoOverlap constraints to all intervals for each instructor/studio\
byInstr.values().forEach(list -> m.addNoOverlap(list));\
byStudio.values().forEach(list -> m.addNoOverlap(list));\
\
// Set the objective: maximize the number of placed priority blocks\
m.maximize(LinearExpr.sum(presences.toArray(new IntVar[0])));\
\
// ... solve the model ...\
```\
*Simplified code showing how priority requests become optional intervals and constraints*\
\
This code creates an `IntervalVar` for each priority request, but makes it *optional* using the `BoolVar present`. The solver then works to find values for the `start` variables and the `present` variables that satisfy all constraints while maximizing the sum of the `present` variables.\
\
After solving, the code checks which `present` variables ended up being true (value is 1) and creates `LockedBlock` objects for those, storing their determined `startSlot` and `lengthSlots`.\
\
```java\
// From DanceTimetableSolver.java (inside solveStageA, after solver finishes)\
\
// ... check solver status ...\
\
if(s.solve(m)==CpSolverStatus.OPTIMAL||s.solve(m)==CpSolverStatus.FEASIBLE)\{\
    int i = 0;\
    for(PriorityReq pr : PRIORITY)\{\
        if(s.value(presences.get(i)) == 1)\{ // If the 'present' variable is true (1)\
            int start = (int) s.value(priorityStartVars.get(pr)); // Get the assigned start slot\
            confirm.add(new LockedBlock(pr.instr, pr.studio, start, pr.hours * DUR60)); // Create LockedBlock\
        \}\
        i++;\
    \}\
\}\
\
return new StageAResult(confirm); // Return the list of successfully placed blocks\
```\
*Simplified code showing how placed blocks are confirmed*\
\
These `LockedBlock`s are the final output of Stage A. They represent the high-priority items that have been successfully scheduled and are now fixed parts of the timetable.\
\
## Output of Stage A\
\
The direct output of the `solveStageA` function is a list of `LockedBlock` objects. These are saved to a file (like `solverA.json`) so that Stage B can read them.\
\
The `solverA.json` file looks like this:\
\
```json\
[ \{\
  "instr" : "Ava",\
  "studioId" : "A",\
  "startSlot" : 228,\
  "lengthSlots" : 36\
\}, \{\
  "instr" : "Liam",\
  "studioId" : "A",\
  "startSlot" : 288,\
  "lengthSlots" : 24\
\} ]\
```\
*Example content of `solverA.json`*\
\
This means Stage A successfully scheduled a block for "Ava" starting at slot 228 for 36 slots (3 hours) and a block for "Liam" starting at slot 288 for 24 slots (2 hours). These slots are within Studio A in this simplified example. These blocks are now "locked" and cannot be moved or removed in Stage B.\
\
## Conclusion\
\
Priority Requests (Stage A) allow us to handle crucial, often longer, scheduling needs before tackling the main bulk of the timetable. By running the solver in a dedicated first stage focused *only* on these requests, we maximize the chances of fitting them successfully. The output of Stage A is a set of confirmed, "locked" blocks that form the fixed foundation upon which the rest of the timetable will be built.\
\
In the next chapter, we'll look at the second stage of the solving process: [Class Requests (Stage B)](05_class_requests__stage_b__.md), where the solver fills in the remaining time slots around the locked priority blocks with regular classes.\
\
[Class Requests (Stage B)](05_class_requests__stage_b__.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/InstructorPriority.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/assumptions.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/InstructorPriority.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/assumptions.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 5: Class Requests (Stage B)\
\
Welcome back! In our previous chapter, [Priority Requests (Stage A)](04_priority_requests__stage_a__.md), we saw how the StudioApp solver tackles the most important scheduling needs first, like dedicated practice blocks for instructors. The output of that first stage was a set of confirmed, "locked-in" time blocks ([Locked Blocks](08_locked_blocks_.md)) that are now a fixed part of our timetable.\
\
But a dance studio timetable isn't just priority blocks! It's mostly filled with the regular, standard dance classes that students sign up for week after week. How do we fit all of *those* into the schedule, making sure they don't collide with the priority blocks or each other?\
\
## The Problem: Filling the Gaps with Standard Classes\
\
After Stage A has placed the critical, high-priority items, the timetable still has many empty slots. We have a list of standard classes that need to be scheduled, such as:\
\
*   "Intro to Basework" (1 session per week)\
*   "Intermediate 2 Aerial Tricks" (2 sessions per week)\
*   "Silky Pole Choreo" (2 sessions per week)\
\
These classes have specific requirements: they need a certain [Instructor](03_instructors_.md) (who might only be available at certain times, a concept we'll cover more in [Availability](06_availability_.md)), they need a [Studio (Room)](02_studios__rooms__.md), and they need a specific duration (usually 60 minutes in our example, which is 12 [Time Slots](01_time_slots_.md) if `slotMinutes` is 5).\
\
The challenge is to place as many of these standard classes as possible into the remaining available [Time Slots](01_time_slots_.md) in the various [Studios (Rooms)](02_studios__rooms__.md), making sure:\
\
1.  They **do not overlap** with any of the [Locked Blocks](08_locked_blocks_.md) already scheduled in Stage A.\
2.  They **do not overlap** with any other standard class placed in the same [Studio (Room)](02_studios__rooms__.md) at the same time.\
3.  They **do not overlap** with any other activity (including Stage A blocks or other classes) assigned to the same [Instructor](03_instructors_.md) at the same time.\
4.  They are scheduled during the [Instructor](03_instructors_.md)'s available times ([Availability](06_availability_.md)).\
5.  They are scheduled during the [Studio (Room)](02_studios__rooms__.md)'s operating hours.\
\
This is where **Stage B** comes in.\
\
## The Solution: The Filling Stage\
\
**Stage B** of the StudioApp solver is the second phase where the primary goal is to schedule the standard "Class Requests". It operates *after* Stage A has completed and the [Locked Blocks](08_locked_blocks_.md) are fixed.\
\
Think of it like a puzzle. Stage A places the large, important pieces. Stage B then takes all the smaller, regular pieces (the classes) and tries to fit them into all the available spaces *around* the fixed pieces, following all the puzzle rules (constraints).\
\
The solver in Stage B is configured to find a timetable that includes all the fixed [Locked Blocks](08_locked_blocks_.md) from Stage A and fits as many Class Requests as possible into the remaining valid spots.\
\
## What Defines a Class Request?\
\
In StudioApp, a standard class request is defined by a few key pieces of information:\
\
| Property              | Description                                                                 | Example Value(s)                             |\
| :-------------------- | :-------------------------------------------------------------------------- | :------------------------------------------- |\
| `classId`             | A unique identifier for the type of class.                                | `"intro_to_basework"`, `"silky_pole_choreo"` |\
| `sessionsPerWeek`     | How many times this specific class needs to run each week.                  | `1`, `2`                                     |\
\
This information comes from the `classesRequired.json` file:\
\
```json\
[\
    \{"classId":"intro_to_basework","sessionsPerWeek":1\},\
    \{"classId":"inter_2_aerial_tricks","sessionsPerWeek":2\},\
    \{"classId":"silky_pole_choreo","sessionsPerWeek":2\},\
    // ... many more class requirements ...\
]\
```\
*A snippet from `classesRequired.json`*\
\
This file tells us *how many instances* of each class type we need to schedule in the week.\
\
Additionally, each class instance needs an [Instructor](03_instructors_.md). This link is made using the `classesByInstructor.json` file:\
\
```json\
\{\
  "classesByInstructor": \{\
    "Ava": [\
      "intro_to_basework",\
      // ... other class IDs Ava can teach ...\
    ],\
    "Liam": [\
      "adv_xo_pole_choreo",\
      // ... other class IDs Liam can teach ...\
    ],\
    // ... more instructors and the classes they can teach ...\
  \}\
\}\
```\
*A snippet from `classesByInstructor.json`*\
\
By combining `classesRequired.json` (how many times we need a class) and `classesByInstructor.json` (which instructors can teach it), the system knows how many individual class instances need to be scheduled and who can teach them. For simplicity in the demo, each class instance is assigned to *one* specific instructor from this list and placed in a single default studio. In a real app, it might need to pick from multiple instructors or studios.\
\
The duration of these classes is typically a standard value defined in `assumptions.json`, like `defaultClassDurationHours`. If this is 1 hour, each standard class will require 12 [Time Slots](01_time_slots_.md) (assuming 5-minute slots).\
\
## How Stage B Works\
\
Stage B takes the result of Stage A and builds upon it.\
\
1.  **Load Locked Blocks:** Read the confirmed [Locked Blocks](08_locked_blocks_.md) from the file saved by Stage A (e.g., `solverA.json`).\
2.  **Initialize Solver Model:** Create a new solver model. Importantly, the [Locked Blocks](08_locked_blocks_.md) from Stage A are added to this model as **fixed intervals**. This means the solver *must* respect these times and cannot place anything else in the same [Studio (Room)](02_studios__rooms__.md) or for the same [Instructor](03_instructors_.md) during those fixed periods.\
3.  **Load Class Requests:** Read the requirements for standard classes from the JSON data. For each required session of each class, identify the [Instructor](03_instructors_.md) (based on `classesByInstructor.json`) and the required duration (usually 1 hour, converted to [Time Slots](01_time_slots_.md)).\
4.  **Represent as Optional Intervals:** For each individual standard class session that needs scheduling, the solver creates an `OptionalIntervalVar`. Just like in Stage A, "optional" means the solver will *try* to schedule it, but might not succeed for all of them if constraints are too tight.\
5.  **Apply Constraints:**\
    *   Ensure each optional class interval, *if scheduled*, fits within the required [Studio (Room)](02_studios__rooms__.md)'s operating hours and the assigned [Instructor](03_instructors_.md)'s [Availability](06_availability_.md) windows. (Details on [Availability](06_availability_.md) are in Chapter 6).\
    *   Apply the `NoOverlap` constraint for *each* [Instructor](03_instructors_.md). This list of intervals *now includes* the fixed Stage A blocks for that instructor *and* all the optional Stage B class intervals assigned to them. The solver must ensure no overlaps among any of these.\
    *   Apply the `NoOverlap` constraint for *each* [Studio (Room)](02_studios__rooms__.md). This list of intervals *now includes* the fixed Stage A blocks in that studio *and* all the optional Stage B class intervals being considered for that studio. The solver must ensure no overlaps among any of these.\
6.  **Solve for Max Classes:** Tell the solver to find a schedule that includes all the fixed intervals and places as many of the optional Class Request intervals as possible. The objective is usually to maximize the total number of scheduled classes.\
7.  **Output:** The solver provides a complete timetable, showing the times and locations for the fixed Stage A blocks and all the Class Request intervals that were successfully scheduled in Stage B.\
\
Here's a simplified look at the interaction during Stage B:\
\
```mermaid\
sequenceDiagram\
    participant LockedBlockA\
    participant ClassRequestX\
    participant ClassRequestY\
    participant SolverB\
    participant StudioConstraints\
    participant InstructorConstraints\
    participant AvailabilityConstraints\
\
    LockedBlockA->>SolverB: I am FIXED at Slot 228 in StudioA for InstructorAva!\
    ClassRequestX->>SolverB: Try to place me (1hr "Basework", InstructorAva, StudioA)\
    ClassRequestY->>SolverB: Try to place me (1hr "Choreo", InstructorLiam, StudioB)\
\
    SolverB->>StudioConstraints: Check StudioA/B availability, respecting LockedBlockA\
    Note over StudioConstraints: StudioA is blocked at Slot 228. Check other slots.\
    StudioConstraints-->>SolverB: StudioA available at Slot 100, StudioB at Slot 300.\
    SolverB->>InstructorConstraints: Check InstructorAva/Liam freedom, respecting LockedBlockA\
    Note over InstructorConstraints: InstructorAva is busy at Slot 228. Check other slots.\
    InstructorConstraints-->>SolverB: InstructorAva free at Slot 100, InstructorLiam free at Slot 300.\
    SolverB->>AvailabilityConstraints: Check if times are within availability?\
    AvailabilityConstraints-->>SolverB: Yes, both within windows.\
\
    Note over SolverB: Finds valid placements for X and Y avoiding conflicts\
\
    SolverB-->>ClassRequestX: Success! Scheduled at Slot 100.\
    SolverB-->>ClassRequestY: Success! Scheduled at Slot 300.\
\
    Note over SolverB: Records placed classes and outputs full timetable\
```\
*(This diagram simplifies the complex constraint satisfaction process, but shows Stage B working around the fixed block.)*\
\
The output of Stage B is the full, finalized timetable incorporating both the fixed priority blocks and the successfully scheduled standard classes.\
\
## Code Implementation Notes (Simplified)\
\
Let's look at snippets from `DanceTimetableSolver.java` to see how this works.\
\
First, in the `main` method, after potentially running or loading Stage A results, the data for classes is loaded:\
\
```java\
// From DanceTimetableSolver.java (main method snippet)\
\
// ... after loading Stage A locked blocks into 'locked' list ...\
\
System.out.println("DEBUG \uc0\u10140  loading classCatalog.json \'85");\
// Loads info about each class type (like name)\
List<Map<String, Object>> classCatalogList = tryLoadList(... "classCatalog.json" ...);\
\
System.out.println("DEBUG \uc0\u10140  loading classesByInstructor.json \'85");\
// Loads which instructors can teach which class IDs\
Map<String, List<String>> cbiJson = ... // Load the map structure\
\
System.out.println("DEBUG \uc0\u10140  loading classesRequired.json \'85");\
// Loads how many sessions of each class ID are needed\
List<Map<String, Object>> reqJson = tryLoadList(... "classesRequired.json" ...);\
\
// Map class IDs to their names\
Map<String, String> classNames = classCatalogList.stream()\
        .collect(Collectors.toMap(m -> (String) m.get("id"),\
                                  m -> (String) m.get("name")));\
\
// Build the list of individual ClassReq objects to be scheduled\
CLASSES = new ArrayList<>();\
for (Map.Entry<String, List<String>> entry : cbiJson.entrySet()) \{\
    String instructorName = entry.getKey();\
    List<String> classIds = entry.getValue(); // Class IDs this instructor can teach\
\
    Instructor instructor = instrMap.get(instructorName); // Get Instructor object\
    if (instructor == null) continue; // Skip if instructor data is missing\
\
    for (String classId : classIds) \{\
        String className = classNames.get(classId); // Get class name from catalog\
        if (className == null) continue; // Skip if class ID not in catalog\
\
        // We need to know how many sessions of this class are required total...\
        // (The current simple demo code adds *all* classes an instructor can teach once,\
        // it doesn't fully use classesRequired.json's sessionsPerWeek count per classId\
        // in this loop, which is a simplification for the demo structure).\
        // For a real app, you'd iterate reqJson and find suitable instructors for each req.\
\
        // For simplicity, adding one instance of each class an instructor can teach to the list of things TO SCHEDULE\
        // And hardcoding Studio A for now.\
        CLASSES.add(new ClassReq(className, instructor, A));\
    \}\
\}\
\
// Call the Stage B solver function with the loaded locked blocks\
solveStageB(locked);\
```\
*Simplified code showing data loading for classes before Stage B*\
\
This shows how the different JSON files are used together to figure out which classes need to be scheduled and who can teach them.\
\
Now, inside the `solveStageB` function, see how the `locked` blocks are handled and the classes are added:\
\
```java\
// From DanceTimetableSolver.java (inside solveStageB)\
\
private static void solveStageB(List<LockedBlock> locked)\{\
    CpModel m = new CpModel();\
    Map<Instructor,List<IntervalVar>> byInstr = new HashMap<>();\
    Map<Studio,List<IntervalVar>> byStudio = new HashMap<>();\
    List<IntVar> classBools = new ArrayList<>(); // To track which classes are scheduled\
    List<ClassNode> nodes = new ArrayList<>(); // Helper to link class reqs to solver variables\
\
    // 1. Insert locked blocks from Stage A as FIXED intervals\
    for(LockedBlock lb : locked)\{\
        // Create a FIXED interval: it MUST be scheduled at this specific start and length\
        IntervalVar fixed = m.newFixedInterval(lb.startSlot, lb.lengthSlots, "lock_"+lb.instr.name+"_s"+lb.startSlot);\
        // Add this fixed interval to the NoOverlap lists for its instructor and studio\
        byInstr.computeIfAbsent(lb.instr, k -> new ArrayList<>()).add(fixed);\
        byStudio.computeIfAbsent(lb.studio, k -> new ArrayList<>()).add(fixed);\
    \}\
\
    // 2. Add ordinary classes as OPTIONAL intervals\
    for(int id = 0; id < CLASSES.size(); id++)\{\
        ClassReq c = CLASSES.get(id);\
        int lenSlots = DUR60; // Standard class length (60 mins = 12 slots)\
\
        // Variable for the start time (can be any slot not conflicting)\
        IntVar start = m.newIntVar(0, TOTAL_SLOTS - lenSlots, "s"+id+"_"+c.title.replace(" ","_"));\
        // Boolean variable: true if this class session is scheduled\
        BoolVar run = m.newBoolVar("run"+id+"_"+c.title.replace(" ","_"));\
        // Variable for the end time (start + length), only relevant if 'run' is true\
        IntVar end = m.newIntVar(0, TOTAL_SLOTS, "e"+id+"_"+c.title.replace(" ","_"));\
\
        // Link start, length, end, and 'run' boolean. End = Start + Length if run is true.\
        m.addEquality(LinearExpr.sum(new LinearArgument[]\{start, m.newConstant(lenSlots)\}), end).onlyEnforceIf(run);\
\
        // Create an optional interval for this class session\
        IntervalVar iv = m.newOptionalIntervalVar(start, m.newConstant(lenSlots), end, run, "iv_c_" + id + "_" + c.title.replace(" ","_"));\
\
        // Add this optional interval to the NoOverlap lists for its instructor and studio\
        // Note: These lists already contain the FIXED intervals from locked blocks\
        byInstr.computeIfAbsent(c.instr, k -> new ArrayList<>()).add(iv);\
        byStudio.computeIfAbsent(c.studio, k -> new ArrayList<>()).add(iv);\
\
        // Add constraints to ensure placement is within instructor's availability windows IF scheduled ('run' is true)\
        // addWindowConstraints is explained in detail in Chapter 6 (Availability).\
        addWindowConstraints(m, start, lenSlots, c.instr.windows, run);\
\
        // Keep track of the 'run' boolean so we can maximize the sum later\
        classBools.add(run);\
        // Keep track of the start variable and 'run' boolean for printing results later\
        nodes.add(new ClassNode(c, start, run));\
    \}\
\
    // 3. Apply NoOverlap constraints for each instructor and studio\
    // These constraints now apply to the combined list of FIXED and OPTIONAL intervals\
    byInstr.values().forEach(m::addNoOverlap);\
    byStudio.values().forEach(m::addNoOverlap);\
\
    // 4. Set the objective: maximize the number of scheduled classes\
    // We sum the 'run' boolean variables. Each 'run' that is true (1) adds 1 to the sum.\
    m.maximize(LinearExpr.sum(classBools.toArray(new IntVar[0])));\
\
    // 5. Solve the model\
    CpSolver s = new CpSolver();\
    s.getParameters().setMaxTimeInSeconds(10); // Give it up to 10 seconds\
    s.getParameters().setNumSearchWorkers(8); // Use multiple threads for faster search\
    CpSolverStatus st = s.solve(m);\
\
    // 6. Process and print results\
    if(st == CpSolverStatus.OPTIMAL || st == CpSolverStatus.FEASIBLE)\{\
        printTimetable(locked, nodes, s); // Print the combined timetable\
    \} else \{\
        System.err.println("No feasible fill schedule (" + st + ")");\
    \}\
\}\
```\
*Simplified code showing the core logic of Stage B*\
\
This code demonstrates the key steps: loading the fixed blocks, creating optional variables for classes, adding them to the `NoOverlap` constraints (which now prevent overlaps with the fixed blocks as well), enforcing availability, and telling the solver to find a solution that schedules the most classes.\
\
The solver then searches for values for the `start` and `run` variables for each class request that satisfy all the constraints while maximizing the number of `run` variables set to true.\
\
## Output of Stage B\
\
The output of Stage B is the final, complete timetable printed to the console. It will show the [Locked Blocks](08_locked_blocks_.md) identified in Stage A (marked with \uc0\u55357 \u57314  in the demo output) and the standard classes successfully scheduled in Stage B (marked with \u55357 \u57313 ).\
\
```text\
\'97\'97\'97 Confirmed priority blocks \'97\'97\'97\
\uc0\u55357 \u57314  Ava Mon 20:00\u8209 23:00 Studio A\
\uc0\u55357 \u57314  Liam Tue 20:00\u8209 22:00 Studio A\
\
\'97\'97\'97 Stage B Timetable \'97\'97\'97\
\uc0\u55357 \u57313  Intro to Basework with Ava Studio A Mon 17:00\
\uc0\u55357 \u57313  Silky Pole Choreo with Olivia Studio A Mon 18:00\
\uc0\u55357 \u57313  Silky Pole Choreo with Olivia Studio A Mon 19:00\
\uc0\u55357 \u57314  Ava Mon 20:00\u8209 23:00 Studio A\
... (more classes and priority blocks)...\
```\
*Example snippet of Stage B output*\
\
Notice how the Stage B classes (\uc0\u55357 \u57313 ) are scheduled *around* the fixed Stage A blocks (\u55357 \u57314 ), respecting the available times in the studio and for the instructor. The solver successfully found slots for these classes without causing any conflicts with the priority blocks or each other.\
\
## Conclusion\
\
Class Requests (Stage B) represent the bulk of the scheduling work \'96 fitting the standard classes into the timetable. By taking the fixed [Locked Blocks](08_locked_blocks_.md) from Stage A and adding them as mandatory constraints, Stage B ensures that the high-priority items are never disturbed. The solver then works to place as many standard classes as possible into the remaining slots, while strictly adhering to [Studio (Room)](02_studios__rooms__.md) capacity, [Instructor](03_instructors_.md) limitations (including [Availability](06_availability_.md)), and avoiding any overlaps.\
\
Understanding how Stage A sets the foundation and Stage B fills the gaps is key to understanding the two-stage approach.\
\
In the next chapter, we'll take a closer look at [Availability](06_availability_.md) \'96 the concept of when Instructors (and potentially Studios) are actually available to be scheduled, which is crucial for both Stage A and Stage B.\
\
[Availability](06_availability_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/classCatalog.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/classesByInstructor.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/classesRequired.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/classCatalog.json), [[6]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/classesByInstructor.json), [[7]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/classesRequired.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 6: Availability\
\
Welcome back! In our journey through the StudioApp scheduling system, we've covered the fundamental building blocks: [Time Slots](01_time_slots_.md) (the grid for *when*), [Studios (Rooms)](02_studios__rooms__.md) (the places *where* activities happen, preventing room clashes), and [Instructors](03_instructors_.md) (the people *who* lead activities, preventing person clashes). We then saw how the two-stage solving process first places high-priority items in [Priority Requests (Stage A)](04_priority_requests__stage_a__.md) and then fills the gaps with [Class Requests (Stage B)](05_class_requests__stage_b__.md).\
\
But there's a crucial layer missing when we talk about **Instructors**: they aren't available 24/7!\
\
## The Problem: People Aren't Always Available\
\
Just like a studio might only be open during specific hours, an instructor has their own schedule outside of the studio. They have family commitments, other jobs, or simply prefer not to work at certain times.\
\
Imagine our instructor, Ava. While Studio A might be open from 4:30 PM to 10:00 PM every weekday, Ava might *only* be available to teach or practice on Monday evenings from 5:00 PM to 9:00 PM and Thursday evenings from 6:00 PM to 10:00 PM.\
\
The scheduler **must** respect these personal boundaries. You cannot schedule Ava for a class at 4:45 PM on Monday, even if the studio is open, because she isn't available yet. You also can't schedule her until 9:30 PM on Monday because her availability ends at 9:00 PM.\
\
Simply put, any activity assigned to an instructor must fall entirely *within* the specific time windows they have declared they are available.\
\
## The Solution: Defining Availability Windows\
\
StudioApp solves this by allowing us to define specific **Availability** windows for each [Instructor](03_instructors_.md). These are explicit time ranges on given days when an instructor *can* be scheduled.\
\
Think of it like setting your "office hours" for the week. You tell people you are only available for meetings during those specific times. Anyone wanting to schedule a meeting with you has to pick a time slot that fits *within* one of your declared office hours.\
\
The scheduler uses these Availability windows as strict constraints. An activity linked to an instructor can *only* be placed in [Time Slots](01_time_slots_.md) that are part of one of their defined Availability windows.\
\
## What Defines Availability?\
\
Availability is typically defined per [Instructor](03_instructors_.md) as a list of time ranges over the week. In the sample data, this is stored in the `availability.json` file:\
\
```json\
[\
  \{"instructor":"Ava","day":"MONDAY","start":"17:00","end":"21:00"\},\
  \{"instructor":"Ava","day":"THURSDAY","start":"18:00","end":"22:00"\},\
  \{"instructor":"Liam","day":"TUESDAY","start":"16:00","end":"20:00"\},\
  // ... more instructors and their availability windows ...\
]\
```\
*A snippet from `availability.json` showing instructor availability*\
\
Each entry in this list represents a single block of time when an instructor is available:\
\
| Property     | Description                                                                   | Example Value(s)             |\
| :----------- | :---------------------------------------------------------------------------- | :--------------------------- |\
| `instructor` | The name (ID) of the [Instructor](03_instructors_.md) this availability is for. | `"Ava"`, `"Liam"`            |\
| `day`        | The day of the week.                                                          | `"MONDAY"`, `"THURSDAY"`     |\
| `start`      | The starting time of the availability window on that day.                     | `"17:00"`, `"18:00"`         |\
| `end`        | The ending time of the availability window on that day. (The instructor is available *up to* this time, but not *at* this time for the *end* of an activity). | `"21:00"`, `"22:00"`         |\
\
These times (`start`, `end`) are converted into ranges of [Time Slots](01_time_slots_.md). For example, if `slotMinutes` is 5, Ava's Monday window from 17:00 to 21:00 is a continuous block of (21:00 - 17:00) = 4 hours = 240 minutes = 48 slots. If Monday's operating hours start at 16:30 (Slot 0 for Monday), then 17:00 is at Slot 6 (30 mins / 5 mins per slot). So, Ava is available from Slot 6 up to the slot *before* the one corresponding to 21:00. Any activity scheduled for Ava on Monday must start and end entirely within this sequence of 48 slots (from Slot 6 to Slot 53 relative to Monday's start).\
\
## The Availability Constraint: Fitting Inside a Window\
\
The core constraint is: **If an activity (class or block) is scheduled for an instructor, its entire duration ([lengthSlots](01_time_slots_.md)) must fit within one of that instructor's defined Availability windows.**\
\
An activity cannot start before the start of an availability window, and it cannot end after the end of that window.\
\
Consider an instructor with two availability windows on different days. A single class for that instructor could be placed in *either* window, but it *must* be placed in *one or the other* if it is scheduled at all. It cannot be placed outside of any window, and it cannot span across two windows (unless the windows are contiguous, but even then, it must align with the window boundaries).\
\
## How the Solver Handles Availability Constraints\
\
The OR-Tools CP-SAT solver enforces this by adding specific constraints for each activity and its assigned instructor's availability windows.\
\
Remember that each activity (both Stage A priority blocks and Stage B classes) is represented by:\
*   `start`: An `IntVar` representing the activity's starting [Time Slot](01_time_slots_.md).\
*   `lenSlots`: A fixed integer representing the activity's duration in slots.\
*   `lit`: A `BoolVar` that is true (1) if the activity is scheduled, and false (0) if it is not.\
\
The solver needs to ensure that *if* `lit` is true, then `start` and `start + lenSlots` fall within the bounds of *one* of the instructor's availability windows.\
\
Let's look at the simplified helper function `addWindowConstraints` from `DanceTimetableSolver.java` that does this:\
\
```java\
// From DanceTimetableSolver.java (Simplified concept)\
private static void addWindowConstraints(CpModel m, IntVar start, int lenSlots, List<Availability> windows, BoolVar lit)\{\
    List<Literal> optionals=new ArrayList<>(); // Collect booleans for each window option\
    for(Availability av:windows)\{\
        // Convert availability time window (start, end) to slot indices (ws, we)\
        int ws=toSlot(av.day,av.from), we=toSlot(av.day,av.to); // ws = window start slot, we = window end slot\
\
        // Create a boolean variable that is true IF this activity is scheduled WITHIN *this specific* window\
        BoolVar wlit=m.newBoolVar("win");\
\
        // If this window is used (wlit is true), the activity must start >= window start slot (ws)\
        m.addGreaterOrEqual(start, ws).onlyEnforceIf(wlit);\
\
        // If this window is used (wlit is true), the activity must end <= window end slot (we)\
        // The activity ends at start + lenSlots. So, start + lenSlots <= we, or start <= we - lenSlots.\
        m.addLessOrEqual(start, we - lenSlots).onlyEnforceIf(wlit);\
\
        // Collect this window's boolean literal. These represent the DIFFERENT window options.\
        optionals.add(wlit);\
\
        // If this window is used (wlit is true), the activity itself must be present (lit must be true)\
        // This links the window choice back to the activity's overall scheduling status.\
        m.addImplication(wlit, lit);\
    \}\
\
    // If the activity is present (lit is true), *exactly one* of the availability windows must be used (one wlit must be true)\
    // We add lit.not() to the list of optionals. If lit is false (activity not present), then lit.not() is true,\
    // satisfying the exactly one constraint with zero wlit being true.\
    optionals.add(lit.not()); // Add the inverse of the activity's presence variable\
    m.addExactlyOne(optionals); // Exactly one of the booleans in 'optionals' must be true\
\}\
```\
*Simplified code explaining availability constraints*\
\
Let's break down the `addWindowConstraints` function call flow:\
\
1.  **Input:** The function gets the solver model (`m`), the activity's potential `start` slot variable, the activity's fixed `lenSlots`, the list of the instructor's `windows`, and the activity's `lit` boolean (whether it's scheduled).\
2.  **Window Options:** For *each* availability window the instructor has, it creates a boolean variable (`wlit`). This `wlit` represents the choice: "Is *this* activity being placed in *this specific* window?"\
3.  **Window Boundaries:** If the solver decides to place the activity in a specific window (by making that window's `wlit` true), constraints are added using `onlyEnforceIf(wlit)` to ensure the activity's `start` and calculated end (`start + lenSlots`) fall within the slot range (`ws`, `we`) of *that* window.\
4.  **Linking Window to Activity:** An implication constraint (`m.addImplication(wlit, lit)`) is added. This means if a window is chosen (`wlit` is true), the activity *must* be scheduled overall (`lit` must be true). This prevents the solver from saying "I'll put it in this window" if it isn't actually scheduling the activity.\
5.  **Exactly One Window:** The clever part is the `m.addExactlyOne(optionals)` constraint. The `optionals` list contains a `wlit` boolean for every availability window *plus* the inverse of the activity's presence boolean (`lit.not()`).\
    *   If the activity *is* scheduled (`lit` is true, `lit.not()` is false), then exactly one of the `wlit` booleans must be true. This means the activity is placed in *exactly one* availability window.\
    *   If the activity is *not* scheduled (`lit` is false, `lit.not()` is true), then `lit.not()` satisfies the `addExactlyOne` constraint by itself, requiring *zero* `wlit` booleans to be true. This correctly represents that the activity isn't placed in any window if it's not scheduled at all.\
\
This function is called for every `PriorityReq` in `solveStageA` and every `ClassReq` in `solveStageB`, using the `windows` list from the instructor assigned to that specific activity.\
\
This ensures that whether the solver is placing a high-priority practice block or a standard class, it will always respect the instructor's defined available times. If there isn't enough contiguous space for an activity's `lenSlots` within *any* of an instructor's windows, or if placing it there would cause an overlap (handled by the `NoOverlap` constraint), the solver will either try a different time slot *within a valid window* or, if it's an optional activity (most Stage B classes and Stage A blocks), it might choose *not* to schedule that activity at all.\
\
## Availability for Studios?\
\
While the current sample data focuses on Instructor availability, the concept of defining availability windows could also apply to [Studios (Rooms)](02_studios__rooms__.md). The `dailyOperatingHours` already provide a form of availability, but you could imagine a scenario where a room is temporarily unavailable *within* operating hours (e.g., closed for maintenance). This would be modeled similarly, by defining specific time windows for the studio and constraining activities to only be placed within those available times, in addition to the `NoOverlap` constraint for the studio. The `addWindowConstraints` logic could potentially be adapted for this too.\
\
However, in the current `DanceTimetableSolver.java` code, this function is specifically used for instructor availability, while studio availability is implicitly handled by limiting the `startSlot` ranges based on `dailyOperatingHours`.\
\
## Conclusion\
\
Availability is a critical concept for ensuring the feasibility and practicality of the generated timetable. By defining specific time windows when [Instructors](03_instructors_.md) are available, we add essential real-world constraints to the scheduling problem. The solver uses these definitions to restrict the possible placements of activities, ensuring that no instructor is ever scheduled outside their declared working times. This constraint is applied uniformly in both [Priority Requests (Stage A)](04_priority_requests__stage_a__.md) and [Class Requests (Stage B)](05_class_requests__stage_b__.md), working alongside [Time Slots](01_time_slots_.md), [Studios (Rooms)](02_studios__rooms__.md), and [Instructor](03_instructors_.md) `NoOverlap` constraints.\
\
Now that we understand all the core components and constraints, we're ready to look at how Stage A and Stage B work together as a complete [Two-Stage Solving](07_two_stage_solving_.md) process.\
\
[Two-Stage Solving](07_two_stage_solving_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/assumptions.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/availability.json), [[4]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/assumptions.json), [[5]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/availability.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 7: Two-Stage Solving\
\
Welcome back to the StudioApp tutorial! In the previous chapters, we've built up our understanding of the core components of the scheduling problem: [Time Slots](01_time_slots_.md) (the time grid), [Studios (Rooms)](02_studios__rooms__.md) (the locations), [Instructors](03_instructors_.md) (the people), [Availability](06_availability_.md) (when people/rooms are free), [Priority Requests (Stage A)](04_priority_requests__stage_a__.md) (special blocks), and [Class Requests (Stage B)](05_class_requests__stage_b__.md) (standard classes).\
\
Now, let's look at the overall strategy StudioApp uses to tackle the entire problem and bring all these pieces together: **Two-Stage Solving**.\
\
## The Problem: A Really Big Puzzle\
\
Imagine trying to build a weekly timetable for a busy studio with dozens of classes, multiple instructors, different rooms, varying class lengths, specific instructor availability, *and* special requests for things like instructor practice time. Trying to fit *everything* all at once \'96 the 3-hour priority blocks *and* all the 1-hour standard classes \'96 is like trying to solve a giant jigsaw puzzle where all the pieces are the same color. It's incredibly complex and can be overwhelming for a computer solver. It might struggle to find a place for the large, inflexible pieces if it's also trying to place hundreds of smaller pieces simultaneously.\
\
## The Solution: Build the Foundation First\
\
StudioApp uses a **Two-Stage Solving** approach to manage this complexity. It breaks the problem down into two distinct, sequential phases:\
\
1.  **Stage A: Place the High-Priority Foundation:** First, the solver focuses *only* on scheduling the most important, potentially less flexible items, like the longer priority time blocks requested by instructors (as we discussed in [Chapter 4: Priority Requests (Stage A)](04_priority_requests__stage_a__.md)).\
2.  **Stage B: Fill in the Rest:** Once the priority items are scheduled, they become fixed. Then, the solver runs a second stage to schedule all the standard class requests (from [Chapter 5: Class Requests (Stage B)](05_class_requests__stage_b__.md)) around these now-fixed priority blocks.\
\
Think of it like building a house:\
\
*   **Stage A** is like building the main structure, the walls, and perhaps adding key features like support beams or foundational elements. These are the critical, often larger pieces that determine the overall layout. You *must* place these first.\
*   **Stage B** is like adding all the internal rooms, furniture, and decorations. You fit these smaller details into the spaces defined by the main structure built in Stage A. You can't put furniture in a room before the walls are up!\
\
This step-by-step approach makes the problem much more manageable:\
\
*   **Prioritization:** Ensures that critical, hard-to-place items get the best chance of being scheduled.\
*   **Complexity Reduction:** The solver in each stage deals with a smaller, more focused problem. Stage A deals with fewer (but perhaps longer) items, and Stage B deals with many items but has a fixed landscape to work around.\
\
## How the Two Stages Work Together\
\
Here's the typical workflow when you run the StudioApp solver in its default "both" mode:\
\
1.  **Data Loading:** The system loads all the input data: [Time Slots](01_time_slots_.md) configuration, [Studios (Rooms)](02_studios__rooms__.md), [Instructors](03_instructors_.md), [Availability](06_availability_.md), [Priority Requests (Stage A)](04_priority_requests__stage_a__.md), and [Class Requests (Stage B)](05_class_requests__stage_b__.md).\
2.  **Run Stage A Solver:** The first solver process starts. It considers *only* the high-priority requests (in our demo, instructor blocks > 1 hour). It respects studio operating hours, instructor availability, and ensures no overlaps *among* these priority blocks in the same studio or for the same instructor. Its objective is usually to schedule as many of these priority blocks as possible.\
3.  **Confirm & Cache Stage A Results:** After Stage A finds a solution, the blocks it successfully scheduled are marked as confirmed. These confirmed blocks are saved to a temporary file (like `solverA.json`). These are the [Locked Blocks](08_locked_blocks_.md) we'll discuss in the next chapter.\
4.  **Load [Locked Blocks](08_locked_blocks_.md):** The saved [Locked Blocks](08_locked_blocks_.md) from Stage A are loaded.\
5.  **Run Stage B Solver:** The second solver process starts. This new model is built differently:\
    *   The [Locked Blocks](08_locked_blocks_.md) from Stage A are added as **fixed, unmovable constraints**.\
    *   All the standard class requests (and potentially any 1-hour priority blocks not handled in Stage A) are added as **optional requests** to be scheduled.\
    *   Constraints are applied: respecting studio hours, instructor availability, and ensuring **no overlaps** between *any* scheduled item (fixed Stage A blocks or new Stage B classes) in the same studio or for the same instructor.\
6.  **Generate Final Timetable:** Stage B finds a solution that incorporates the fixed Stage A blocks and schedules as many standard classes as possible around them. The final output is the complete timetable.\
\
Here's a simplified flow diagram:\
\
```mermaid\
sequenceDiagram\
    participant User\
    participant StudioApp\
    participant StageA_Solver\
    participant StageA_Cache\
    participant StageB_Solver\
\
    User->>StudioApp: Run Solver\
    StudioApp->>StageA_Solver: Solve Priority Requests (> 1hr blocks)\
    StageA_Solver-->>StudioApp: Results: Placed Priority Blocks\
    StudioApp->>StageA_Cache: Save Placed Blocks (Locked Blocks)\
    StudioApp->>StageA_Cache: Load Saved Locked Blocks\
    StageA_Cache-->>StudioApp: Locked Blocks Data\
    StudioApp->>StageB_Solver: Solve Class Requests (using Locked Blocks as fixed)\
    StageB_Solver-->>StudioApp: Results: Full Timetable (Locked + Classes)\
    StudioApp-->>User: Display Timetable\
```\
\
## Code Implementation Overview\
\
The `DanceTimetableSolver.java` code directly implements this two-stage process using separate methods for each stage.\
\
The `main` method orchestrates the process:\
\
```java\
// From DanceTimetableSolver.java (Simplified main method)\
\
// ... load initial data (Instructors, Availability, Priority Requests) ...\
\
List<LockedBlock> locked;\
final String CACHE = "src/main/resources/sample_data/solverA.json";\
\
// Run Stage A if configured, or load from cache\
if (runA) \{\
    StageAResult stageA = solveStageA(); // Call the Stage A solver method\
    locked = stageA.locked;\
    saveLockedBlocks(locked, CACHE); // Save results\
\} else \{\
    locked = loadLockedBlocks(CACHE, instrMap); // Load previous results\
\}\
\
// ... load Class Requests data ...\
\
// Run Stage B, passing the locked blocks from Stage A\
solveStageB(locked); // Call the Stage B solver method\
\
// ... print final timetable in solveStageB ...\
```\
*Simplified code flow in `main`*\
\
As you can see, the `main` method first calls `solveStageA()`. The result, a list of `LockedBlock` objects, is saved and then passed as an argument to the `solveStageB()` method. This clearly separates the two phases and ensures Stage B operates on the results of Stage A.\
\
The `solveStageA` method (covered in [Chapter 4](04_priority_requests__stage_a__.md)) creates a solver model focused on optional priority blocks. The `solveStageB` method (covered in [Chapter 5](05_class_requests__stage_b__.md)) creates a *new* solver model where the `LockedBlock`s are added first as `FixedInterval`s before the optional class intervals are added.\
\
This structure in the code directly mirrors the two-stage strategy: Stage A determines the fixed points, and Stage B builds around them.\
\
## Benefits of Two-Stage Solving\
\
*   **Solvability:** Complex scheduling problems can be computationally hard. Breaking it down often helps the solver find *any* feasible solution, and sometimes a better one, by fixing important variables early.\
*   **Guaranteed Placement (for A):** High-priority items are guaranteed to be attempted and, if a solution exists, prioritized for placement.\
*   **Clear Problem Definition:** Each stage has a clear, more limited scope, making the logic easier to design and understand.\
\
## Conclusion\
\
Two-Stage Solving is the core strategic pattern used by StudioApp's solver. It splits the complex task of creating a timetable into a foundational phase ([Stage A: Priority Requests](04_priority_requests__stage_a__.md)) and a filling phase ([Stage B: Class Requests](05_class_requests__stage_b__.md)). By first securing the placement of critical, high-priority items and then scheduling standard classes around those fixed points, the solver manages complexity and produces a practical timetable. The output of Stage A, the confirmed priority placements, are known as [Locked Blocks](08_locked_blocks_.md), which are essential inputs for Stage B.\
\
In the next chapter, we'll delve deeper into these [Locked Blocks](08_locked_blocks_.md) \'96 what they are, where they come from, and why they are crucial for Stage B.\
\
[Locked Blocks](08_locked_blocks_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 8: Locked Blocks\
\
Welcome back to the StudioApp tutorial! In the [previous chapter](07_two_stage_solving_.md), we learned about the overall strategy StudioApp uses: [Two-Stage Solving](07_two_stage_solving_.md). This approach tackles the scheduling problem by first focusing on high-priority items in Stage A and then fitting everything else around them in Stage B.\
\
But how does Stage B *know* exactly where those high-priority items were placed by Stage A? How do they become "fixed" parts of the schedule that Stage B must respect? This is where the concept of **Locked Blocks** comes in.\
\
## The Problem: Remembering Stage A's Decisions\
\
Imagine Stage A successfully finds a perfect time and place for Ava's 3-hour priority practice block. Great! But when Stage B starts working on scheduling all the regular classes, it needs to know:\
\
1.  *Exactly* when and where Ava's block is scheduled (which [Time Slots](01_time_slots_.md) in which [Studio (Room)](02_studios__rooms__.md)).\
2.  That this block is **fixed** \'96 it cannot be moved, changed, or unscheduled by Stage B.\
3.  That no other activity (neither a Stage B class nor anything else) can be scheduled in that same [Studio (Room)](02_studios__rooms__.md) or for that same [Instructor](03_instructors_.md) during those specific [Time Slots](01_time_slots_.md).\
\
Without this information, Stage B might accidentally try to schedule a class right on top of Ava's practice time, creating a conflict and an invalid timetable.\
\
## The Solution: The Locked Blocks\
\
The successfully scheduled output of [Priority Requests (Stage A)](04_priority_requests__stage_a__.md) is captured as a list of **Locked Blocks**. These blocks represent specific, confirmed appointments for particular instructors in particular studios at particular times.\
\
Think of them as "pre-booked reservations" on your studio calendar. Once a reservation is made (a block is "locked"), that time slot and location are taken. Anything else you want to schedule later has to find an available slot *around* that reservation.\
\
When Stage B runs, it *loads* these Locked Blocks. Instead of treating them as flexible requests to be scheduled, it treats them as **unmovable obstacles** or **fixed constraints** in the solver model.\
\
## What Defines a Locked Block?\
\
A Locked Block is a simple piece of data that records the concrete outcome for a priority request that Stage A successfully scheduled. It contains the essential information about the confirmed appointment:\
\
| Property      | Description                                                                 | Example Value(s)             |\
| :------------ | :-------------------------------------------------------------------------- | :--------------------------- |\
| `instr`       | The [Instructor](03_instructors_.md) assigned to this block.              | `Ava`, `Liam`                |\
| `studioId`    | The ID of the [Studio (Room)](02_studios__rooms__.md) where it's scheduled.| `"A"`, `"B"`                 |\
| `startSlot`   | The precise starting [Time Slot](01_time_slots_.md) index for the block.    | `228`, `288`                 |\
| `lengthSlots` | The duration of the block in [Time Slots](01_time_slots_.md).               | `36`, `24`                   |\
\
This information is typically saved to a file after Stage A completes. In our demo, this file is `solverA.json`.\
\
```json\
[ \{\
  "instr" : "Ava",\
  "studioId" : "A",\
  "startSlot" : 228,\
  "lengthSlots" : 36\
\}, \{\
  "instr" : "Liam",\
  "studioId" : "A",\
  "startSlot" : 288,\
  "lengthSlots" : 24\
\} ]\
```\
*Example content of `solverA.json`, representing two Locked Blocks*\
\
This JSON shows that Stage A successfully scheduled:\
*   A block for "Ava" in "Studio A" starting at slot 228, lasting 36 slots (3 hours).\
*   A block for "Liam" in "Studio A" starting at slot 288, lasting 24 slots (2 hours).\
\
These are the exact details that Stage B needs.\
\
## How Locked Blocks Are Used in Stage B\
\
The process looks like this:\
\
1.  **Stage A Completes:** The solver finishes running for [Priority Requests (Stage A)](04_priority_requests__stage_a__.md) and identifies which blocks were placed.\
2.  **Save Locked Blocks:** The details of the placed blocks (`instr`, `studioId`, `startSlot`, `lengthSlots`) are saved, for example, to `solverA.json`.\
3.  **Stage B Starts:** Stage B initializes its own solver model.\
4.  **Load Locked Blocks:** The list of Locked Blocks is read from the saved file (`solverA.json`).\
5.  **Add as Fixed Constraints:** For *each* Locked Block loaded:\
    *   A **fixed interval** is added to the solver model. A fixed interval means this activity *must* happen at its specified `startSlot` and `lengthSlots`.\
    *   This fixed interval is added to the `NoOverlap` constraints for its specific [Instructor](03_instructors_.md) and its specific [Studio (Room)](02_studios__rooms__.md). This tells the solver that these time slots are now occupied for both the instructor and the studio by an unmovable block.\
\
This process ensures that when Stage B then tries to schedule all the [Class Requests (Stage B)](05_class_requests__stage_b__.md) (which are added as *optional* intervals, as discussed in [Chapter 5](05_class_requests__stage_b__.md)), the solver is automatically prevented from placing any class that would overlap with one of the fixed Locked Blocks.\
\
Here's a simple flow showing the transfer of information:\
\
```mermaid\
sequenceDiagram\
    participant StageA\
    participant File (solverA.json)\
    participant StageB_Solver\
    participant StageB_Model\
\
    StageA->>File: Save successfully placed priority blocks\
    File-->>StageB_Solver: Load Locked Blocks data\
    StageB_Solver->>StageB_Model: Add each Loaded Block as a FIXED interval\
    StageB_Solver->>StageB_Model: Add Class Requests as OPTIONAL intervals\
    StageB_Solver->>StageB_Model: Apply NoOverlap constraints (including FIXED intervals)\
    StageB_Solver->>StageB_Model: Solve... respecting FIXED blocks\
```\
\
## Code Implementation Notes (Simplified)\
\
Let's look at how this is handled in `DanceTimetableSolver.java`.\
\
First, after Stage A finishes in the `main` method, the `locked` list is saved:\
\
```java\
// From DanceTimetableSolver.java (main method snippet)\
\
// ... inside the 'if (runA)' block ...\
\
StageAResult stageA = solveStageA(); // Stage A returns a list of LockedBlocks\
locked = stageA.locked;\
saveLockedBlocks(locked, CACHE); // Call function to save the list\
\
// ... rest of main method ...\
```\
*Snippet showing saving Locked Blocks after Stage A*\
\
The `saveLockedBlocks` function simply takes the list of `LockedBlock` objects and writes them to the specified JSON file:\
\
```java\
// From DanceTimetableSolver.java (Simplified saveLockedBlocks function)\
\
private static void saveLockedBlocks(List<LockedBlock> locked, String path) \{\
    // Code to create parent directory if needed...\
\
    List<Map<String, Object>> data = new ArrayList<>();\
    for (LockedBlock lb : locked) \{\
        Map<String, Object> row = new LinkedHashMap<>();\
        row.put("instr", lb.instr.name);       // Get instructor name\
        row.put("studioId", lb.studio.id);     // Get studio ID\
        row.put("startSlot", lb.startSlot);   // Get start slot\
        row.put("lengthSlots", lb.lengthSlots); // Get length in slots\
        data.add(row); // Add this data row to the list\
    \}\
\
    // Code to write 'data' list as pretty JSON to the file...\
\}\
```\
*Simplified code for saving Locked Blocks to JSON*\
\
Then, whether Stage A just ran or was skipped (`!runA`), the `locked` blocks are loaded:\
\
```java\
// From DanceTimetableSolver.java (main method snippet)\
\
// ... after the 'if (runA)' block ...\
\
else \{ // Stage A was skipped\
    // Load previously saved blocks from the cache file\
    locked = loadLockedBlocks(CACHE, instrMap); // Call function to load from file\
    // Handle case where file is missing/empty...\
\}\
\
// Now the 'locked' list is populated, whether from running Stage A or loading the cache\
\
// ... Pass 'locked' list to solveStageB ...\
solveStageB(locked);\
```\
*Snippet showing loading Locked Blocks before Stage B*\
\
The `loadLockedBlocks` function reads the JSON file and converts the data back into `LockedBlock` objects:\
\
```java\
// From DanceTimetableSolver.java (Simplified loadLockedBlocks function)\
\
private static List<LockedBlock> loadLockedBlocks(String path, Map<String, Instructor> instrMap) \{\
    File f = new File(path);\
    if (!f.exists()) return Collections.emptyList(); // Return empty list if file not found\
\
    // Code to read JSON file into a List of Maps... (example shown in 'What Defines...')\
\
    List<LockedBlock> list = new ArrayList<>();\
    for (var m : raw) \{ // Loop through the loaded data maps\
        String instrName = (String) m.get("instr");\
        Instructor instr = instrMap.computeIfAbsent(instrName, Instructor::new); // Find or create Instructor object\
        String studioId = (String) m.get("studioId");\
        Studio studio = "B".equals(studioId) ? B : A; // Find Studio object (using demo's simple A/B logic)\
        int start = ((Number) m.get("startSlot")).intValue();\
        int len   = ((Number) m.get("lengthSlots")).intValue();\
        list.add(new LockedBlock(instr, studio, start, len)); // Create a new LockedBlock object\
    \}\
    return list; // Return the list of Locked Blocks\
\}\
```\
*Simplified code for loading Locked Blocks from JSON*\
\
Finally, inside the `solveStageB` method, these `locked` blocks are added to the solver model as fixed intervals *before* any of the optional classes are added:\
\
```java\
// From DanceTimetableSolver.java (inside solveStageB)\
\
private static void solveStageB(List<LockedBlock> locked)\{\
    CpModel m=new CpModel();\
    Map<Instructor,List<IntervalVar>> byInstr=new HashMap<>();\
    Map<Studio,List<IntervalVar>> byStudio=new HashMap<>();\
    // ... other lists for Stage B classes ...\
\
    // Insert locked blocks as fixed intervals\
    for(LockedBlock lb:locked)\{\
        // Create a FIXED interval using the LoadedBlock data\
        IntervalVar fixed=m.newFixedInterval(lb.startSlot, lb.lengthSlots, "lock_"+lb.instr.name);\
        // Add this FIXED interval to the NoOverlap lists for Instructor and Studio\
        byInstr.computeIfAbsent(lb.instr,k->new ArrayList<>()).add(fixed);\
        byStudio.computeIfAbsent(lb.studio,k->new ArrayList<>()).add(fixed);\
    \}\
\
    // Now, loop through ordinary classes and add them as OPTIONAL intervals...\
    // ... code for adding ClassReqs as optional intervals ...\
\
    // Apply NoOverlap constraints. These lists now contain FIXED and OPTIONAL intervals.\
    byInstr.values().forEach(m::addNoOverlap); // No overlaps *for this instructor* (including fixed blocks)\
    byStudio.values().forEach(m::addNoOverlap); // No overlaps *in this studio* (including fixed blocks)\
\
    // ... rest of Stage B solver setup and solving ...\
\}\
```\
*Simplified code showing how Locked Blocks become fixed intervals in Stage B*\
\
This is the core mechanism. By using `m.newFixedInterval(...)`, the solver is told that this interval *must* be present at this exact time and place. When `m.addNoOverlap` is then called on the lists containing these fixed intervals and the new optional class intervals, the solver is forced to find a schedule for the optional classes that *avoids* the times and locations already claimed by the fixed Locked Blocks.\
\
## Conclusion\
\
Locked Blocks are the crucial data structure that bridges the gap between Stage A and Stage B of the StudioApp solver. They represent the concrete outcome of Stage A's efforts to place high-priority items. By saving these confirmed placements and then loading them into Stage B as fixed, unmovable constraints using `m.newFixedInterval`, StudioApp ensures that the second stage builds the rest of the timetable around the already-scheduled foundation, respecting the critical requirements identified in the first stage. They act as the "taken" slots that Stage B must navigate around.\
\
In the next chapter, we'll step back and look at the main Java class, `DanceTimetableSolver`, and see how all these concepts fit together within the overall code structure.\
\
[DanceTimetableSolver](09_dancetimetablesolver_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/resources/sample_data/solverA.json), [[3]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/target/classes/sample_data/solverA.json)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 9: DanceTimetableSolver\
\
Welcome back to the StudioApp tutorial! We've spent the last few chapters digging into the essential pieces of our scheduling puzzle: the time grid ([Time Slots](01_time_slots_.md)), the locations ([Studios (Rooms)](02_studios__rooms__.md)), the people ([Instructors](03_instructors_.md)) and when they're free ([Availability](06_availability_.md)). We also looked at the strategy ([Two-Stage Solving](07_two_stage_solving_.md)) and how the results of the first stage are saved ([Locked Blocks](08_locked_blocks_.md)).\
\
Now, it's time to bring it all together! In this chapter, we introduce the **DanceTimetableSolver** \'96 the main program class that acts as the conductor of our scheduling orchestra.\
\
## The Problem: Making the Whole System Run\
\
We have all these concepts and data inputs: files describing instructors, studios, classes needed, availability times, and priority requests. We have a strategy (two stages) and tools ([OR-Tools CP-SAT Solver](10_or_tools_cp_sat_solver_.md), which we'll cover next). But how does it all *work*? How does the program load everything, decide which stage to run, pass data between stages, call the solver, and produce the final timetable?\
\
## The Solution: The DanceTimetableSolver Class\
\
The `DanceTimetableSolver` class is the central hub of the StudioApp scheduling application. It's a single Java class that contains the `main` method \'96 the entry point when you run the program. Its job is to:\
\
1.  Read all the configuration and input data files.\
2.  Set up and execute the [Two-Stage Solving](07_two_stage_solving_.md) process.\
3.  Handle the output of each stage, including saving and loading [Locked Blocks](08_locked_blocks_.md).\
4.  Present the final scheduled timetable.\
\
Think of the `DanceTimetableSolver` class as the control center or the "brain" that coordinates all the different parts we've discussed. It doesn't *invent* the concepts like [Time Slots](01_time_slots_.md) or solve the complex math itself (that's the job of the OR-Tools solver it uses), but it knows *how* to use them and *in what order*.\
\
## How It Works: The Main Flow\
\
The `main` method within the `DanceTimetableSolver.java` file orchestrates the entire process. Here's a simplified look at the sequence of actions it performs:\
\
1.  **Load Configuration & Base Data:** It first loads fundamental settings and data, such as the `slotMinutes`, studio definitions ([Studios (Rooms)](02_studios__rooms__.md)), and instructor availability ([Instructors](03_instructors_.md), [Availability](06_availability_.md)). This data is needed for both stages.\
2.  **Prepare for Stage A:** It identifies which input requests are high-priority blocks ([Priority Requests (Stage A)](04_priority_requests__stage_a__.md)) according to the defined rules (like blocks longer than 1 hour in the demo).\
3.  **Run or Load Stage A:** Based on how you run the program (e.g., with command-line arguments), it decides whether to:\
    *   Run the solver for Stage A to find placements for priority blocks.\
    *   *Or*, load previously saved [Locked Blocks](08_locked_blocks_.md) from a file (the output of a prior Stage A run).\
4.  **Handle Stage A Results:** If Stage A is run, it gets the list of successfully scheduled priority blocks (the [Locked Blocks](08_locked_blocks_.md)). It then saves this list to a file (like `solverA.json`). If Stage A was skipped, it loads this file instead.\
5.  **Prepare for Stage B:** It loads the data for standard classes ([Class Requests (Stage B)](05_class_requests__stage_b__.md)).\
6.  **Run Stage B:** It calls the solver function for Stage B, passing it the list of [Locked Blocks](08_locked_blocks_.md) obtained from step 4.\
7.  **Output Final Timetable:** After Stage B finishes, it prints the complete timetable, showing both the fixed [Locked Blocks](08_locked_blocks_.md) and the successfully scheduled standard classes.\
\
Here's a sequence diagram illustrating this main flow within the `DanceTimetableSolver` class:\
\
```mermaid\
sequenceDiagram\
    participant User\
    participant DanceTimetableSolver\
    participant DataLoader\
    participant StageASolverMethod\
    participant LockedBlockFile\
    participant StageBSolverMethod\
    participant OutputPrinter\
\
    User->>DanceTimetableSolver: Run application (main)\
    DanceTimetableSolver->>DataLoader: Load basic data (Studios, Instructors, Availability)\
    DanceTimetableSolver->>DataLoader: Load Priority Requests\
    DanceTimetableSolver->>DanceTimetableSolver: Decide whether to run Stage A\
    alt Run Stage A\
        DanceTimetableSolver->>StageASolverMethod: Solve Stage A (Priority Blocks)\
        StageASolverMethod-->>DanceTimetableSolver: List of Placed Priority Blocks\
        DanceTimetableSolver->>LockedBlockFile: Save Placed Blocks\
    else Load Stage A Cache\
        DanceTimetableSolver->>LockedBlockFile: Load Locked Blocks\
        LockedBlockFile-->>DanceTimetableSolver: List of Locked Blocks\
    end\
    DanceTimetableSolver->>DataLoader: Load Class Requests\
    DanceTimetableSolver->>StageBSolverMethod: Solve Stage B (Classes) with Locked Blocks\
    StageBSolverMethod-->>DanceTimetableSolver: Final Timetable Solution\
    DanceTimetableSolver->>OutputPrinter: Format and print Timetable\
    OutputPrinter-->>User: Display Timetable\
```\
*(This diagram shows the main steps orchestrated by the `DanceTimetableSolver`.)*\
\
## Looking at the Code (Simplified `main`)\
\
Let's peek at the core `main` method in `DanceTimetableSolver.java`. We'll break it down into small parts.\
\
First, initializing OR-Tools and handling command-line arguments to pick the mode (stageA, stageB, or both):\
\
```java\
// From DanceTimetableSolver.java (main method)\
public static void main(String[] args)\{\
    Loader.loadNativeLibraries(); // Initialize OR-Tools\
\
    /* \uc0\u9472 \u9472 \u9472  Determine mode: stageA | stageB | both (default) \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  */\
    String mode = args.length > 0 ? args[0].toLowerCase() : "both";\
    boolean runA = mode.equals("stagea") || mode.equals("a") || mode.equals("both");\
    boolean runB = mode.equals("stageb") || mode.equals("b") || mode.equals("both");\
\
    // ... rest of main method ...\
\}\
```\
*Snippet showing initialization and mode selection*\
\
This code sets up the necessary OR-Tools library and checks if the user wants to run Stage A, Stage B, or both based on the input `args`.\
\
Next, loading the data needed for both stages (Availability, Instructor Priorities):\
\
```java\
// From DanceTimetableSolver.java (main method)\
\
// ... after mode selection ...\
\
/* \uc0\u9472 \u9472 \u9472  Load JSON data common to both stages \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  */\
\
// Availability  \uc0\u9472 \u9472  build instructors map\
// Loads availability data from JSON and populates the 'instrMap'\
List<Map<String, String>> avJson = tryLoadList("availability.json", ...);\
Map<String, Instructor> instrMap = new HashMap<>();\
for (var row : avJson) \{\
    // Logic to create/get Instructor objects and add availability windows\
    instrMap.computeIfAbsent(...);\
\}\
\
// Instructor priorities (used to filter Stage A requests)\
// Loads priority requests from JSON\
List<Map<String, Object>> prJson = tryLoadList("InstructorPriority.json", ...);\
\
/* --- Filter: Stage\'a0A should schedule only blocks longer than 1\uc0\u8239 hour --- */\
PRIORITY = prJson.stream()\
        .filter(m -> ((Number) m.get("blockLengthHours")).intValue() > 1) // Keep > 1 hour\
        .sorted(...) // Sort by priority\
        .map(m -> new PriorityReq( // Map to internal object\
                instrMap.get((String) m.get("instructor")),\
                A, // Assume Studio A for demo simplicity\
                ((Number) m.get("blockLengthHours")).intValue()))\
        .toList();\
\
// ... rest of main method ...\
```\
*Snippet showing loading common data and filtering priority requests*\
\
This section reads availability and priority data, creates `Instructor` and `PriorityReq` objects, and populates the `PRIORITY` list, specifically filtering for items intended for Stage A (> 1 hour blocks).\
\
Then, the code handles running Stage A or loading its results:\
\
```java\
// From DanceTimetableSolver.java (main method)\
\
// ... after loading common data and filtering priorities ...\
\
/* \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  MODE: Stage\'a0A only or first \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  */\
List<LockedBlock> locked;\
final String CACHE = "src/main/resources/sample_data/solverA.json"; // Cache file path\
\
if (runA) \{\
    // If runA is true, call the solveStageA method\
    StageAResult stageA = solveStageA();\
    locked = stageA.locked; // Get the placed blocks\
    saveLockedBlocks(locked, CACHE); // Save them to the cache file\
\
    if (!runB) \{\
        // If we only ran Stage A, print a message and exit\
        System.out.println("Stage\'a0A complete...");\
        return; // Exit the program\
    \}\
\} else \{\
    // If runA is false, load the locked blocks from the cache file\
    locked = loadLockedBlocks(CACHE, instrMap);\
    if (locked.isEmpty()) \{\
        System.err.println("No cached Stage\'a0A data found...");\
        return; // Exit if cache is empty\
    \}\
    System.out.println("\\n\'97\'97\'97 Loaded " + locked.size() + " priority blocks from cache \'97\'97\'97");\
\}\
\
// Now, the 'locked' list contains the result from Stage A (either just run or loaded)\
\
// ... rest of main method (Stage B preparation and run) ...\
```\
*Snippet showing Stage A handling*\
\
This crucial part decides whether to execute the `solveStageA()` method (which contains its own solver logic as discussed in [Chapter 4](04_priority_requests__stage_a__.md)), or to load the results using `loadLockedBlocks()` (as discussed in [Chapter 8](08_locked_blocks_.md)). The list of `LockedBlock` objects is stored in the `locked` variable for use in Stage B.\
\
Finally, the code loads the Class Request data and calls the Stage B solver method:\
\
```java\
// From DanceTimetableSolver.java (main method)\
\
// ... after Stage A handling ...\
\
/* \uc0\u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  MODE includes Stage\'a0B \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472  */\
\
System.out.println("DEBUG \uc0\u10140  loading classCatalog.json \'85");\
List<Map<String, Object>> classCatalogList = tryLoadList(...); // Load class types\
\
System.out.println("DEBUG \uc0\u10140  loading classesByInstructor.json \'85");\
Map<String, List<String>> cbiJson = ... // Load which instructor teaches which class\
\
System.out.println("DEBUG \uc0\u10140  loading classesRequired.json \'85");\
List<Map<String, Object>> reqJson = tryLoadList(...); // Load how many sessions needed\
\
// Code to process the loaded class data and create 'CLASSES' list...\
// This involves looking up class names and assigning instructors/studios\
\
// Call the solveStageB method, passing the list of locked blocks\
solveStageB(locked); // This method contains the Stage B solver logic\
\
// The solveStageB method prints the final timetable before main finishes\
```\
*Snippet showing Stage B preparation and run*\
\
This part loads the data needed specifically for Stage B ([Class Requests (Stage B)](05_class_requests__stage_b__.md)), prepares the data into the `CLASSES` list, and then calls the `solveStageB()` method (which contains its own solver logic, incorporating the `locked` blocks, as discussed in [Chapter 5](05_class_requests__stage_b__.md)). The `solveStageB` method is responsible for producing the final output.\
\
As you can see, the `DanceTimetableSolver` class, and specifically its `main` method, acts as the director, calling the right methods at the right time and managing the data flow between them. It is the class that brings all the previously discussed concepts to life in a functional program.\
\
## Conclusion\
\
The `DanceTimetableSolver` class is the orchestrator of the StudioApp scheduling system. It handles loading all necessary input data, implementing the [Two-Stage Solving](07_two_stage_solving_.md) strategy by calling the separate solver methods for Stage A and Stage B, and managing the transfer of [Locked Blocks](08_locked_blocks_.md) between these stages. It is the central piece of code that ties together concepts like [Time Slots](01_time_slots_.md), [Studios (Rooms)](02_studios__rooms__.md), [Instructors](03_instructors_.md), and [Availability](06_availability_.md) to produce a complete timetable using an external solver library.\
\
In the final chapter, we will dive into the powerful tool that does the heavy lifting of finding solutions: the [OR-Tools CP-SAT Solver](10_or_tools_cp_sat_solver_.md).\
\
[OR-Tools CP-SAT Solver](10_or_tools_cp_sat_solver_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/pom.xml), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 # Chapter 10: OR-Tools CP-SAT Solver\
\
Welcome to the final concept chapter of the StudioApp tutorial! In the [previous chapter](09_dancetimetablesolver_.md), we explored the `DanceTimetableSolver` class, which acts as the main coordinator, loading data and orchestrating the [Two-Stage Solving](07_two_stage_solving_.md) process.\
\
But while `DanceTimetableSolver` sets everything up and manages the flow, it doesn't actually perform the complex task of figuring out *which* class goes in *which* [Time Slot](01_time_slots_.md) in *which* [Studio (Room)](02_studios__rooms__.md) with *which* [Instructor](03_instructors_.md), all while avoiding conflicts and respecting [Availability](06_availability_.md) and [Locked Blocks](08_locked_blocks_.md). That requires some heavy computational lifting!\
\
## The Problem: Finding a Valid Timetable Solution\
\
Imagine you've gathered all your requirements:\
*   A list of classes needing to be scheduled, each with a required length.\
*   Which instructors can teach which classes, and when they are available.\
*   Which studios are available at what times.\
*   Any existing, fixed appointments ([Locked Blocks](08_locked_blocks_.md)) that cannot be moved.\
*   The rules: no overlapping classes in the same studio, no overlapping activities for the same instructor, everything must fit within availability windows, etc.\
\
How do you find a timetable that satisfies *all* of these conditions simultaneously? Manually trying every possibility would take an incredibly long time, even for a small studio. This is a classic example of a complex puzzle with many interlocking pieces and strict rules.\
\
## The Solution: The OR-Tools CP-SAT Solver\
\
StudioApp uses a powerful external library from Google called **OR-Tools**, specifically its **CP-SAT solver**. This solver is the sophisticated "engine" that takes our carefully defined scheduling puzzle and efficiently searches for a solution that fits all the rules (constraints).\
\
Think of it like giving a super-smart, super-fast puzzle-solving robot all the puzzle pieces and all the rules (like "blue pieces only go on the edges"). You tell the robot what you want to achieve (e.g., "finish the puzzle, or at least place as many pieces as possible"), and it crunches through the possibilities to find a valid arrangement.\
\
The CP-SAT solver is designed for **Constraint Programming (CP)** and **boolean Satisfiability (SAT)** problems, which are excellent for scheduling and planning tasks where you need to satisfy a set of logical conditions.\
\
## How It Works: Defining the Puzzle for the Solver\
\
The Java code in `DanceTimetableSolver` interacts with the OR-Tools CP-SAT library by building a mathematical model that represents our scheduling problem. This model has three main components:\
\
1.  **Variables:** These are the decisions the solver needs to make. What unknown values does it need to find?\
    *   For each potential activity (a [Priority Request (Stage A)](04_priority_requests__stage_a__.md) block or a [Class Request (Stage B)](05_class_requests__stage_b__.md)), the solver needs to decide its **start time**. In our system, this is the `startSlot`.\
    *   For optional activities (most classes and Stage A blocks before they are [Locked Blocks](08_locked_blocks_.md)), the solver needs to decide **whether to schedule it** at all.\
\
2.  **Constraints:** These are the rules the solver *must* follow. Any proposed solution that violates *any* constraint is invalid.\
    *   No two intervals ([Time Slots](01_time_slots_.md) occupied by activities) can overlap for the same [Studio (Room)](02_studios__rooms__.md). (Handled by `m.addNoOverlap`).\
    *   No two intervals can overlap for the same [Instructor](03_instructors_.md). (Also `m.addNoOverlap`).\
    *   An activity, *if scheduled*, must start and end within the assigned instructor's [Availability](06_availability_.md) window. (Handled by `addWindowConstraints` using `addGreaterOrEqual`, `addLessOrEqual`, `addExactlyOne`, and `onlyEnforceIf`).\
    *   [Locked Blocks](08_locked_blocks_.md) from Stage A are treated as **fixed intervals** \'96 they *must* be in the timetable at their determined time and location, and nothing else can overlap with them.\
\
3.  **Objective:** This tells the solver what makes a "good" solution if there are multiple valid ones, or what to maximize if not everything can be scheduled.\
    *   In Stage A, the objective is to maximize the number of placed priority blocks.\
    *   In Stage B, the objective is to maximize the number of scheduled standard classes.\
\
The `DanceTimetableSolver` code translates all the data and rules from the JSON files and Java objects into this mathematical model (`CpModel`) that the OR-Tools CP-SAT solver understands.\
\
Here's a simplified view of the process:\
\
```mermaid\
sequenceDiagram\
    participant DanceTimetableSolver\
    participant CpModel\
    participant CpSolver\
    participant Hardware(CPU)\
\
    DanceTimetableSolver->>CpModel: Create new model (m)\
    DanceTimetableSolver->>CpModel: Define Variables (start slots, presence booleans...)\
    DanceTimetableSolver->>CpModel: Add Constraints (NoOverlap, Availability, Fixed Intervals...)\
    DanceTimetableSolver->>CpModel: Define Objective (Maximize scheduled items)\
    DanceTimetableSolver->>CpSolver: Create solver instance (s)\
    DanceTimetableSolver->>CpSolver: Call solve(m)\
    CpSolver->>Hardware(CPU): Crunch numbers, explore possibilities, apply logic...\
    Hardware(CPU)-->>CpSolver: Found a solution (or proved no solution / timed out)\
    CpSolver-->>DanceTimetableSolver: Return status (OPTIMAL, FEASIBLE, INFEASIBLE...)\
    DanceTimetableSolver->>CpSolver: Read variable values if solution found (s.value())\
    DanceTimetableSolver-->>DanceTimetableSolver: Use values to build timetable output\
```\
\
## Key OR-Tools Concepts in the Code\
\
Let's look at the main pieces from the OR-Tools library used in `DanceTimetableSolver.java`:\
\
1.  **`CpModel m = new CpModel();`**: This line creates an empty model object. This object is where we will build our puzzle definition (variables, constraints, objective).\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    CpModel m = new CpModel();\
    // ... add variables, constraints, objective to 'm' ...\
    ```\
    *Creating a new CP-SAT model*\
\
2.  **`IntVar start = m.newIntVar(min, max, "name");`**: This creates an **Integer Variable**. The solver needs to find a specific whole number (`int`) value for this variable within the range `min` to `max`. In our case, this is used for the `startSlot` of an activity. The bounds `0` to `TOTAL_SLOTS - length` ensure it can't start too late to finish within the week.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    int lenSlots = pr.hours * DUR60; // Example: duration in slots\
    // Create variable for the start slot, range from 0 to total slots minus duration\
    IntVar start = m.newIntVar(0, TOTAL_SLOTS - lenSlots, "pstart" + pr.instr.name);\
    // ...\
    ```\
    *Creating an Integer Variable for start time*\
\
3.  **`BoolVar present = m.newBoolVar("name");`**: This creates a **Boolean Variable**. The solver needs to decide if this variable is true (1) or false (0). This is used to represent whether an optional activity is scheduled or not.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    // Create a boolean variable to represent if this priority block is scheduled\
    BoolVar present = m.newBoolVar("present" + pr.instr.name);\
    // ...\
    ```\
    *Creating a Boolean Variable for presence*\
\
4.  **`IntervalVar iv = m.newOptionalIntervalVar(start, length, end, presence, "name");`** or **`IntervalVar fixed = m.newFixedInterval(start, length, "name");`**: These create **Interval Variables**. While technically derived from start, end, and length variables, interval variables are a core concept in constraint programming, particularly useful for scheduling.\
    *   `newOptionalIntervalVar` is used for activities that the solver *might* schedule. It links the `start`, `length`, calculated `end`, and the `presence` boolean. The interval is considered "active" only if `presence` is true.\
    *   `newFixedInterval` is used for intervals that *must* be in the solution at a specific `start` and `length`. This is how [Locked Blocks](08_locked_blocks_.md) from Stage A are represented in Stage B.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA)\
    // Create an optional interval variable for a priority request\
    IntervalVar iv = m.newOptionalIntervalVar(start, m.newConstant(lenSlots), end, present, "iv_p_" + pr.instr.name);\
    // ...\
\
    // From DanceTimetableSolver.java (inside solveStageB)\
    // Create a fixed interval for a loaded Locked Block\
    IntervalVar fixed = m.newFixedInterval(lb.startSlot, lb.lengthSlots, "lock"+lb.instr.name);\
    // ...\
    ```\
    *Creating Optional and Fixed Interval Variables*\
\
5.  **`m.addNoOverlap(List<IntervalVar> intervals);`**: This is a crucial **Constraint**. It tells the solver that for all the intervals in the given list, no two intervals can be active at the same time. We use this separately for lists of intervals grouped `byStudio` and `byInstr`.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    // byInstr is a Map where values are Lists of IntervalVars for one instructor\
    byInstr.values().forEach(list -> m.addNoOverlap(list));\
    // byStudio is a Map where values are Lists of IntervalVars for one studio\
    byStudio.values().forEach(m::addNoOverlap);\
    ```\
    *Adding NoOverlap Constraints*\
\
6.  **`m.addLessOrEqual(IntVar var1, IntVar var2).onlyEnforceIf(BoolVar condition);`**: This adds a standard numerical comparison constraint. `addLessOrEqual(var1, var2)` means `var1 <= var2`. The `.onlyEnforceIf(condition)` part is important \'96 it means this constraint *only applies* if the `condition` boolean variable is true. We use this, for example, to say: "IF this activity is scheduled (`run` is true), THEN its start time MUST be less than or equal to the end of the availability window minus its length."\
\
    ```java\
    // From DanceTimetableSolver.java (inside addWindowConstraints)\
    // ws = window start slot, we = window end slot\
    // lenSlots = activity length\
    // lit = activity presence boolean\
    // wlit = boolean if THIS window is used\
    m.addLessOrEqual(start, we - lenSlots).onlyEnforceIf(wlit); // start + lenSlots <= we\
    // ...\
    m.addImplication(wlit, lit); // If this window is used, the activity must be present\
    ```\
    *Adding Conditional Numerical Constraints*\
\
7.  **`m.addExactlyOne(List<Literal> booleans);`**: This constraint ensures that out of all the boolean variables (or their negations, called `Literal`s) in the list, exactly one of them must be true. In `addWindowConstraints`, this is used to ensure that *if* an activity is scheduled, it's placed in *exactly one* of the instructor's availability windows.\
\
    ```java\
    // From DanceTimetableSolver.java (inside addWindowConstraints)\
    // optionals contains wlit for each window AND lit.not()\
    optionals.add(lit.not()); // Add the inverse of the activity's presence\
    m.addExactlyOne(optionals); // Exactly one must be true\
    ```\
    *Adding ExactlyOne Constraint*\
\
8.  **`m.maximize(LinearExpr expression);`**: This defines the **Objective Function**. The solver will try to find a solution that satisfies all constraints *and* makes the value of the given linear expression as large as possible. In our case, the expression is often the sum of the boolean variables representing whether optional items are scheduled.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    // classBools is a list of boolean variables (1 if scheduled, 0 if not)\
    m.maximize(LinearExpr.sum(classBools.toArray(new IntVar[0])));\
    ```\
    *Defining the Maximization Objective*\
\
9.  **`CpSolver s = new CpSolver(); s.solve(m);`**: This creates the **Solver** instance and tells it to find a solution for the model `m`. The solver then goes to work, using sophisticated algorithms to explore the search space defined by the variables and pruned by the constraints.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageA or solveStageB)\
    CpSolver s = new CpSolver();\
    s.getParameters().setMaxTimeInSeconds(10); // Optional: set a time limit\
    s.getParameters().setNumSearchWorkers(8); // Optional: use multiple threads\
    CpSolverStatus st = s.solve(m); // Run the solver!\
    ```\
    *Creating the Solver and Running It*\
\
10. **`s.value(IntVar var)`**: After `s.solve(m)` finishes, if it found a solution (`CpSolverStatus.OPTIMAL` or `CpSolverStatus.FEASIBLE`), you can use `s.value(var)` to get the specific integer or boolean (0 or 1) value that the solver assigned to a variable in the found solution.\
\
    ```java\
    // From DanceTimetableSolver.java (inside solveStageB, processing results)\
    if(s.value(n.run) == 1)\{ // If the 'run' boolean was true (scheduled)\
        long st = s.value(n.start); // Get the assigned start slot\
        // ... use st to print the scheduled activity ...\
    \}\
    ```\
    *Reading Variable Values from the Solution*\
\
By using these building blocks from the OR-Tools CP-SAT library, the `DanceTimetableSolver` class translates the real-world scheduling requirements into a mathematical problem that the solver can efficiently solve, producing the final timetable.\
\
## Conclusion\
\
The **OR-Tools CP-SAT Solver** is the powerful engine that does the heavy computational work of finding a valid timetable. The `DanceTimetableSolver` class acts as its programmer, defining the scheduling problem in terms of variables (the decisions to be made), constraints (the rules to follow), and an objective (what to optimize). OR-Tools then uses advanced algorithms to search for a solution that satisfies all the constraints, delivering the final schedule.\
\
This concludes our journey through the core concepts of the StudioApp scheduling system. We've gone from the basic unit of time ([Time Slots](01_time_slots_.md)) to the locations ([Studios (Rooms)](02_studios__rooms__.md)), the people ([Instructors](03_instructors_.md)) and their constraints ([Availability](06_availability_.md)), the strategic approach ([Two-Stage Solving](07_two_stage_solving_.md)), how information passes between stages ([Locked Blocks](08_locked_blocks_.md)), the orchestrating code (`DanceTimetableSolver`), and finally, the powerful solver engine itself.\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/pom.xml), [[2]](https://github.com/rsung04/StudioApp/blob/ed2b9eeabd1d047ca02829a2db2a18d8479f122c/src/main/java/com/example/timetable/DanceTimetableSolver.java)</sup></sub>\cf4 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \
}