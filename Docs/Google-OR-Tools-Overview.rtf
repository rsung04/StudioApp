{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 # Tutorial: java_or-tools\
\
This project provides a **minimal example** showing how to use the\
**Google OR-Tools library** in a Java application built with **Maven**.\
It demonstrates how to set up a basic optimization problem using OR-Tools\
components like variables, constraints, and an objective, and solve it.\
**GitHub Actions** are used to automatically build and test the project\
across different operating systems, ensuring it works reliably.\
\
\
## Visual Overview\
\
```mermaid\
flowchart TD\
    A0["MPSolver\
"]\
    A1["MPVariable\
"]\
    A2["MPConstraint\
"]\
    A3["MPObjective\
"]\
    A4["Google OR-Tools Library (ortools-java)\
"]\
    A5["Maven Build System\
"]\
    A6["GitHub Actions Workflow\
"]\
    A4 -- "Provides solver" --> A0\
    A0 -- "Creates" --> A1\
    A0 -- "Creates" --> A2\
    A0 -- "Provides" --> A3\
    A2 -- "Uses variable" --> A1\
    A3 -- "Uses variable" --> A1\
    A5 -- "Manages dependency" --> A4\
    A6 -- "Runs build" --> A5\
```\
\
## Chapters\
\
1. [Google OR-Tools Library (ortools-java)\
](01_google_or_tools_library__ortools_java__.md)\
2. [Maven Build System\
](02_maven_build_system_.md)\
3. [MPSolver\
](03_mpsolver_.md)\
4. [MPVariable\
](04_mpvariable_.md)\
5. [MPConstraint\
](05_mpconstraint_.md)\
6. [MPObjective\
](06_mpobjective_.md)\
7. [GitHub Actions Workflow\
](07_github_actions_workflow_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub>\
\
\
# Chapter 1: Google OR-Tools Library (ortools-java)\
\
Welcome to the first chapter of this tutorial! In this chapter, we'll introduce the star of the show: the Google OR-Tools library, specifically its Java version (`ortools-java`).\
\
Imagine you have a tricky problem where you need to make the best possible decisions given certain limitations. For example:\
\
*   You run a factory and need to decide how many units of each product to make to maximize profit, knowing you have limited raw materials and machine time.\
*   You are scheduling shifts for employees and need to cover all hours while respecting their availability and avoiding excessive overtime.\
*   You need to transport goods from warehouses to stores, minimizing transportation costs while meeting demand.\
\
These are all examples of **optimization problems**. Solving them manually can be incredibly difficult or even impossible for complex scenarios. This is where Google OR-Tools comes in!\
\
## What is Google OR-Tools?\
\
Google OR-Tools is an open-source software suite for tackling these kinds of optimization problems. Think of it as a powerful toolbox filled with specialized tools (algorithms) designed to find the *best* possible solution among many possibilities, given your constraints.\
\
It supports many types of optimization, including:\
\
*   **Linear Programming (LP):** Problems where you want to maximize or minimize a linear function subject to linear constraints. (Like our simple example above).\
*   **Integer Programming (IP):** Similar to LP, but some or all decisions must be whole numbers (integers).\
*   **Constraint Programming (CP):** Problems defined by a set of constraints that must be satisfied, often used for scheduling and planning.\
*   And more!\
\
This project, `java_or-tools`, focuses on using the **Java interface** of OR-Tools, provided by the `ortools-java` library. This library allows us to use the powerful OR-Tools engine directly within our Java programs.\
\
## Why Use OR-Tools?\
\
Implementing complex optimization algorithms from scratch is a task for experts and requires deep mathematical knowledge. OR-Tools saves you from this! It provides battle-tested, efficient algorithms developed by Google engineers. Your job is to describe *your specific problem* to OR-Tools using its provided tools (classes and methods), and OR-Tools handles the heavy lifting of finding the solution.\
\
It's like using a calculator for complex math instead of doing it by hand \'96 the calculator (OR-Tools) has the built-in methods; you just need to input your numbers (your problem details).\
\
## How Does OR-Tools Fit into This Project?\
\
The `java_or-tools` project is essentially a demonstration of how to use the `ortools-java` library in a Java project managed with Maven (which we'll cover in the next chapter!). The `BasicExample.java` file you see in the project uses `ortools-java` to define and solve a simple optimization problem.\
\
The project relies on `ortools-java` as an **external dependency**. This means the `java_or-tools` code doesn't *contain* the OR-Tools algorithms itself; it *uses* the algorithms provided by the `ortools-java` library, which is downloaded and included when you build the project.\
\
You can see this dependency declared in the project's build file, `pom.xml`. Here's the relevant snippet:\
\
```xml\
<dependencies>\
  <dependency>\
    <groupId>com.google.ortools</groupId>\
    <artifactId>ortools-java</artifactId>\
    <version>9.12.4544</version> <!-- Version might vary -->\
    <type>jar</type>\
    <scope>compile</scope>\
  </dependency>\
</dependencies>\
```\
\
This XML block tells the build system (Maven) to download and include the `ortools-java` library (with a specific `groupId`, `artifactId`, and `version`) so our code can use its classes and methods.\
\
## Using OR-Tools: A First Look\
\
Let's look at tiny pieces of the `BasicExample.java` code to see how `ortools-java` is used. Don't worry about understanding everything yet; we'll cover the details of `MPSolver`, `MPVariable`, etc., in later chapters. This is just to show you how the library is brought into play.\
\
First, you need to load the necessary OR-Tools native code. OR-Tools has core parts written in C++ for performance, and the Java library acts as a bridge.\
\
```java\
// [START loader]\
Loader.loadNativeLibraries();\
// [END loader]\
```\
\
This line (`Loader.loadNativeLibraries()`) initializes the OR-Tools library, making its functions available to your Java code.\
\
Next, you create a "solver" object. This object is your main interface to the OR-Tools engine. You specify which specific algorithm you want to use (like "GLOP" for Linear Programming, which is a solver developed by Google).\
\
```java\
// [START solver]\
// Create the linear solver with the GLOP backend.\
MPSolver solver = MPSolver.createSolver("GLOP");\
if (solver == null) \{\
  System.out.println("Could not create solver GLOP");\
  return;\
\}\
// [END solver]\
```\
\
Here, `MPSolver.createSolver("GLOP")` asks OR-Tools to give us an object capable of solving Linear Programming problems using the GLOP algorithm.\
\
Then, you use the `solver` object to define the parts of your problem: the decisions you need to make (variables), the rules they must follow (constraints), and what you want to maximize or minimize (the objective).\
\
```java\
// [START variables]\
// Create the variables x and y.\
MPVariable x = solver.makeNumVar(0.0, 1.0, "x");\
MPVariable y = solver.makeNumVar(0.0, 2.0, "y");\
// [END variables]\
\
// [START constraints]\
// Create a linear constraint, x + y <= 2.\
MPConstraint ct = solver.makeConstraint(-infinity, 2.0, "ct");\
ct.setCoefficient(x, 1);\
ct.setCoefficient(y, 1);\
// [END constraints]\
\
// [START objective]\
// Create the objective function, 3 * x + y.\
MPObjective objective = solver.objective();\
objective.setCoefficient(x, 3);\
objective.setCoefficient(y, 1);\
objective.setMaximization();\
// [END objective]\
```\
\
These snippets show how OR-Tools provides classes like `MPVariable` and `MPConstraint` and methods on the `MPSolver` object to build your mathematical model piece by piece.\
\
Finally, you tell the solver to find the solution:\
\
```java\
// [START solve]\
final MPSolver.ResultStatus resultStatus = solver.solve();\
// [END solve]\
```\
\
The `solver.solve()` method is where OR-Tools does its work! It takes the model you've defined and runs its algorithms to find the optimal values for your variables.\
\
After solving, you can ask the solver for the results:\
\
```java\
// [START print_solution]\
System.out.println("Solution:");\
System.out.println("Objective value = " + objective.value());\
System.out.println("x = " + x.solutionValue());\
System.out.println("y = " + y.solutionValue());\
// [END print_solution]\
```\
\
You can retrieve the final objective value and the specific values OR-Tools found for each variable (`x` and `y`) that satisfy the constraints and optimize the objective.\
\
For our simple example (Maximize `3x + y` subject to `x + y <= 2`, `0 <= x <= 1`, `0 <= y <= 2`), the expected output would show something like:\
\
```\
Solution:\
Objective value = 5.0\
x = 1.0\
y = 1.0\
```\
\
(Because if x=1 and y=1, the constraints are met (1+1=2 <= 2, 0<=1<=1, 0<=1<=2) and the objective (3*1 + 1 = 4) is high. If x=1 and y=2, the first constraint is violated (1+2=3 > 2). If x is less, the objective is lower. The optimal solution is indeed x=1, y=1, giving an objective value of 4. Wait, the example code description implies the objective value is 5. Let's recheck the constraints: x<=1, y<=2, x+y<=2. Maximize 3x+y.\
If x=1, y=1 => 3(1)+1=4. Valid (1<=1, 1<=2, 1+1=2<=2).\
If x=1, what's the max y? y<=2 and 1+y<=2 -> y<=1. So max y is 1.\
If y=2, what's the max x? x<=1 and x+2<=2 -> x<=0. So max x is 0.\
Let's check corners:\
(0,0) -> 3(0)+0=0\
(1,0) -> 3(1)+0=3 (1<=1, 0<=2, 1+0=1<=2)\
(0,2) -> 3(0)+2=2 (0<=1, 2<=2, 0+2=2<=2)\
(1,1) -> 3(1)+1=4 (1<=1, 1<=2, 1+1=2<=2)\
It seems the optimal is (1,1) with objective 4. Let's check the code snippet again: `MPVariable x = solver.makeNumVar(0.0, 1.0, "x"); MPVariable y = solver.makeNumVar(0.0, 2.0, "y"); MPConstraint ct = solver.makeConstraint(-infinity, 2.0, "ct"); ct.setCoefficient(x, 1); ct.setCoefficient(y, 1); objective.setCoefficient(x, 3); objective.setCoefficient(y, 1); objective.setMaximization();`. The constraints are `0 <= x <= 1`, `0 <= y <= 2`, and `x + y <= 2`. The objective is `Maximize 3x + y`.\
The example output comments say `x=1.0`, `y=1.0` and `Objective value = 4.0`. The comment in the code `System.out.println("Objective value = " + objective.value());` also suggests the value is printed directly. Let's assume the example output provided in the prompt was a typo and the correct output for this problem is objective 4.0 with x=1, y=1. Let's correct the expected output description.\
\
For our simple example (Maximize `3x + y` subject to `x + y <= 2`, `0 <= x <= 1`, `0 <= y <= 2`), the expected output would show something like:\
\
```\
Solution:\
Objective value = 4.0\
x = 1.0\
y = 1.0\
```\
\
This indicates that the maximum value of `3x + y` that satisfies all the rules is 4, which occurs when `x` is 1 and `y` is 1.\
\
## How OR-Tools Works (Under the Hood)\
\
When you call `solver.solve()`, a lot happens very quickly! Here's a simplified view of the process:\
\
```mermaid\
sequenceDiagram\
    participant YourJavaApp\
    participant OrToolsJavaLib\
    participant OrToolsNativeCode\
    participant OptimizationAlgorithm\
\
    YourJavaApp->>OrToolsJavaLib: Define variables, constraints, objective...\
    OrToolsJavaLib->>OrToolsNativeCode: Build internal model representation\
\
    Note over OrToolsNativeCode: Translates problem into mathematical form\
\
    OrToolsNativeCode->>OptimizationAlgorithm: Pass model to algorithm (e.g., Simplex)\
    OptimizationAlgorithm-->>OrToolsNativeCode: Finds solution (optimal values)\
\
    OrToolsNativeCode-->>OrToolsJavaLib: Returns results\
\
    Note over OrToolsJavaLib: Makes results accessible via Java objects\
\
    OrToolsJavaLib-->>YourJavaApp: You retrieve solution values\
```\
\
1.  Your Java code, using classes like `MPSolver`, `MPVariable`, etc., describes the optimization problem.\
2.  The `ortools-java` library translates this description into a format that the core OR-Tools native code understands.\
3.  The native OR-Tools code prepares the problem for solving.\
4.  It passes the problem to one of its built-in optimization algorithms (like the Simplex algorithm for Linear Programming).\
5.  The algorithm runs, crunching numbers to find the best solution.\
6.  The native OR-Tools code receives the results (the optimal objective value and the values of the variables).\
7.  These results are passed back to the `ortools-java` library.\
8.  The `ortools-java` library makes these results available to your Java code through methods like `objective.value()` and `variable.solutionValue()`.\
\
You don't need to worry about the complex steps happening inside the "Optimization Algorithm" box. That's the power of using a library like OR-Tools!\
\
## Summary\
\
In this chapter, you learned that Google OR-Tools is a powerful library for solving optimization problems, and `ortools-java` is its Java interface. It provides the core engine and algorithms we'll use in this project. We saw that the project depends on this library and got a first glimpse of how it's used to define and solve a simple problem.\
\
In the next chapter, we'll take a step back and look at **Maven**, the tool that manages external dependencies like `ortools-java` and helps build and run our Java project.\
\
[Chapter 2: Maven Build System](02_maven_build_system_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/pom.xml), [[2]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/src/main/java/org/or_tools/example/BasicExample.java)</sup></sub>\
\
\
# Chapter 2: Maven Build System\
\
Welcome back! In [Chapter 1](01_google_or_tools_library__ortools_java__.md), we met Google OR-Tools and saw how the `ortools-java` library provides the powerful engine for solving optimization problems in Java. We also briefly saw how the project uses `ortools-java` as an external **dependency**, declared in the `pom.xml` file.\
\
But how does the project actually *use* that dependency? How is the Java code compiled? How do you run the application? For complex projects, manually managing all these steps can become a nightmare! You'd need to:\
\
1.  Download the `ortools-java` library and any libraries *it* depends on (and libraries *they* depend on!).\
2.  Make sure the Java compiler knows where to find all these libraries.\
3.  Run the compiler command with all the correct settings.\
4.  Figure out how to bundle everything together to run the application easily.\
\
This is where a **build system** comes in.\
\
## What is Maven?\
\
Maven is a popular project management and build tool for Java projects. Its main goal is to make the build process easier and more standardized.\
\
Think of Maven as the project's dedicated manager and build engineer. Instead of you having to tell Java *exactly* how to find files, compile code, download libraries, and run the application every single time, you tell *Maven* what your project is about and what you want to achieve (like "compile the code" or "run the app"), and Maven figures out the necessary steps.\
\
For the `java_or-tools` project, Maven handles these essential tasks:\
\
*   **Dependency Management:** Automatically downloading `ortools-java` and any other required libraries from the internet.\
*   **Compilation:** Turning your human-readable Java code (`.java` files) into machine-executable code (`.class` files).\
*   **Execution:** Running the compiled Java application.\
*   **Packaging:** Bundling everything needed to run the application into a single, easy-to-distribute file (like a JAR).\
\
## How Maven Works: The `pom.xml` File\
\
The heart of every Maven project is the `pom.xml` file (POM stands for **P**roject **O**bject **M**odel). This XML file contains all the configuration for the project. It tells Maven things like:\
\
*   The project's name, version, etc.\
*   Which external libraries (dependencies) the project needs.\
*   How to build the project (e.g., which Java version to use).\
*   How to run specific tasks using plugins.\
\
Let's look at simplified parts of the `pom.xml` file from the `java_or-tools` project:\
\
```xml\
<project xmlns="http://maven.apache.org/POM/4.0.0" ...>\
    <modelVersion>4.0.0</modelVersion>\
\
    <!-- Basic project information -->\
    <groupId>org.or-tools.example</groupId>\
    <artifactId>BasicExample</artifactId>\
    <version>1.0.0</version>\
    <packaging>jar</packaging>\
\
    <properties>\
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\
        <exec.mainClass>org.or_tools.example.BasicExample</exec.mainClass>\
        <maven.compiler.source>1.8</maven.compiler.source>\
        <maven.compiler.target>1.8</maven.compiler.target>\
    </properties>\
\
    <!-- Dependencies section -->\
    <dependencies>\
        <dependency>\
            <groupId>com.google.ortools</groupId>\
            <artifactId>ortools-java</artifactId>\
            <version>9.12.4544</version> <!-- Version might vary -->\
            <type>jar</type>\
            <scope>compile</scope>\
        </dependency>\
    </dependencies>\
\
    <!-- Build configuration (e.g., plugins) -->\
    <build>\
        <!-- ... plugin configurations ... -->\
    </build>\
</project>\
```\
\
*   `<groupId>`, `<artifactId>`, `<version>`: These uniquely identify *this* project.\
*   `<packaging>`: Says we want to package the project as a JAR file.\
*   `<properties>`: Defines configuration values, like the main class to run (`exec.mainClass`) and the Java version (`maven.compiler.source`, `maven.compiler.target`).\
*   `<dependencies>`: This is where we saw `ortools-java` declared in [Chapter 1](01_google_or_tools_library__ortools_java__.md). It tells Maven to get this specific library.\
*   `<build>`: Contains instructions for the build process, often involving plugins that add capabilities (like compiling, running, packaging, etc.).\
\
Maven reads this file to understand everything about the project and how to build it.\
\
## Standard Maven Commands\
\
Maven provides a set of standard commands (called *phases* or *goals*) that you run from your terminal in the project's root directory (where `pom.xml` is located). Here are the common ones you'll use for this project, as seen in the project's `README.md`:\
\
### 1. Compiling the Code\
\
Before you can run or package your Java code, it needs to be compiled.\
\
```bash\
mvn compile -B\
```\
\
*   `mvn`: This is the command to run Maven.\
*   `compile`: This is the specific phase we want Maven to execute. It tells Maven to compile the main source code (`.java` files, typically found in `src/main/java`).\
*   `-B`: (Optional) This means "Batch Mode". It makes Maven output slightly less verbose information, which is often cleaner.\
\
**What happens:** Maven reads `pom.xml`, checks dependencies, then finds your Java source files and compiles them into `.class` files. These compiled files are placed in a `target/classes` directory within your project.\
\
### 2. Running the Application\
\
After compiling, you can run the main application class.\
\
```bash\
mvn exec:java\
```\
\
*   `mvn`: Run Maven.\
*   `exec:java`: This uses a specific Maven plugin (`exec-maven-plugin`) to run a Java class. Maven knows which class to run because it's defined in the `<properties>` section of `pom.xml` as `<exec.mainClass>org.or_tools.example.BasicExample</exec.mainClass>`.\
\
**What happens:** Maven finds the compiled `.class` files (including the `BasicExample` class and the `ortools-java` library code it downloaded), sets up the necessary environment (including the OR-Tools native libraries), and runs the `main` method in the `BasicExample` class. This will execute the OR-Tools example code we looked at in [Chapter 1](01_google_or_tools_library__ortools_java__.md), and you should see the output printed to your console (the solution to the optimization problem).\
\
### 3. Packaging the Project\
\
Sometimes you want to bundle your compiled code and necessary resources into a single file that can be easily shared or run elsewhere. This is usually a JAR file for Java applications.\
\
```bash\
mvn package -B\
```\
\
*   `mvn`: Run Maven.\
*   `package`: This phase tells Maven to compile the code (if not already done) and then create a JAR file containing your compiled classes and other project resources.\
\
**What happens:** Maven runs the `compile` phase (if needed), and then creates a JAR file (e.g., `BasicExample-1.0.0.jar`) in the `target` directory. This JAR file contains your application's compiled code. Note that for a simple application like this using native OR-Tools libraries, running *just* the JAR might require additional setup to include the native code, but the `package` command itself creates the JAR artifact.\
\
## Maven Under the Hood (Simple View)\
\
How does Maven manage all this? Let's trace a command like `mvn compile`.\
\
```mermaid\
sequenceDiagram\
    participant You\
    participant YourTerminal\
    participant Maven\
    participant pom.xml\
    participant MavenRepoLocal["Maven Local Repository (on your computer)"]\
    participant MavenRepoRemote["Maven Remote Repository (Internet)"]\
    participant YourCode["Your Java Code"]\
\
    You->>YourTerminal: Type "mvn compile"\
    YourTerminal->>Maven: Execute command "compile"\
    Maven->>pom.xml: Read project configuration\
    Note over Maven: Understands dependencies and build settings\
\
    Maven->>MavenRepoLocal: Look for ortools-java dependency\
    alt ortools-java found locally\
        MavenRepoLocal-->>Maven: Dependency available\
    else ortools-java not found locally\
        MavenRepoLocal-->>Maven: Not found\
        Maven->>MavenRepoRemote: Request ortools-java dependency\
        MavenRepoRemote-->>Maven: Send ortools-java library files\
        Maven->>MavenRepoLocal: Save ortools-java locally\
    end\
\
    Maven->>YourCode: Find Java files (e.g., src/main/java/*.java)\
    Maven->>Maven: Use compiler (based on pom.xml settings)\
    Maven->>Maven: Compile YourCode using ortools-java\
    Maven-->>YourTerminal: Report status (BUILD SUCCESS)\
    Note over Maven: Places compiled .class files in target/classes/\
```\
\
1.  You type a command like `mvn compile`.\
2.  Maven starts up and first reads the `pom.xml` file to understand the project's configuration, including its dependencies.\
3.  For each dependency listed (`ortools-java` in our case), Maven first checks a special folder on your computer called the **local Maven repository**.\
4.  If the dependency is found in the local repository, Maven uses that copy.\
5.  If the dependency is *not* found locally, Maven connects to **remote Maven repositories** (like Maven Central, a large repository on the internet) and downloads the required library files. It then saves a copy in your local repository for future use.\
6.  Once all dependencies are resolved and available, Maven proceeds with the requested task (e.g., `compile`). It finds your source code, uses the specified Java compiler (configured often via plugins and properties in `pom.xml`), and compiles your `.java` files into `.class` files, making sure to use the downloaded libraries correctly.\
7.  Finally, Maven reports whether the build was successful or if there were errors.\
\
For commands like `mvn exec:java` or `mvn package`, Maven follows a similar process of reading `pom.xml`, resolving dependencies, and then executing the relevant build steps defined for that phase.\
\
## Why Use Maven?\
\
*   **Standardization:** Maven enforces a standard project structure and build lifecycle, making it easier for developers to understand new Maven projects.\
*   **Dependency Management:** It automates the tedious process of downloading and managing libraries, including transitive dependencies (libraries that your libraries depend on).\
*   **Reproducible Builds:** Because Maven downloads specific versions of dependencies, building the project on different machines or at different times should produce the same results.\
*   **Plugins:** Maven's functionality can be extended with plugins, allowing for various tasks like running tests, generating documentation, running applications, etc.\
\
## Summary\
\
In this chapter, we learned that Maven is the build system for the `java_or-tools` project. It uses the `pom.xml` file to manage project configuration, dependencies, and build instructions. We explored the key commands (`mvn compile`, `mvn exec:java`, `mvn package`) used to build, run, and package the project, understanding what each command does and getting a simplified view of Maven's internal process.\
\
Now that we understand how the project is built and managed, we can dive deeper into the core components of the `ortools-java` library itself, starting with the main object used to define and solve problems: the [MPSolver](03_mpsolver_.md).\
\
[Chapter 3: MPSolver](03_mpsolver_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/Dockerfile), [[2]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/README.md), [[3]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/pom.xml)</sup></sub>\
\
\
# Chapter 3: MPSolver\
\
Welcome back! In the previous chapter, [Chapter 2: Maven Build System](02_maven_build_system_.md), we learned how Maven helps us manage project dependencies like `ortools-java` and handle the build process. Now that we know *how* to compile and run our code, let's dive into the core components of OR-Tools itself, starting with the central piece for defining and solving Linear Programming problems: the `MPSolver`.\
\
In [Chapter 1: Google OR-Tools Library (ortools-java)](01_google_or_tools_library__ortools_java__.md), we saw a glimpse of how an optimization problem is built and solved using OR-Tools. The very first object we created for this purpose was the `MPSolver`.\
\
## What is the MPSolver?\
\
Imagine you have a complex puzzle you need to solve, like figuring out the best production plan for a factory to maximize profit while respecting limited resources. To solve this with OR-Tools, you need a way to:\
\
1.  Describe the puzzle: What are the decisions you can make? What are the rules (limitations)? What are you trying to achieve (maximize profit or minimize cost)?\
2.  Give the description to a powerful calculating engine.\
3.  Tell the engine to find the best possible solution.\
4.  Get the answer from the engine.\
\
The `MPSolver` is that central calculating engine interface in OR-Tools for **M**athematical **P**rogramming problems (like Linear Programming). It's the object you use to:\
\
*   **Create** the pieces of your problem (variables, constraints, objective).\
*   **Contain** the complete description of your problem.\
*   **Solve** the problem using a chosen algorithm.\
*   **Retrieve** the solution once it's found.\
\
Think of the `MPSolver` as a specialized whiteboard where you write down your optimization problem piece by piece, and then you hand it to OR-Tools' powerful brain to solve.\
\
## Creating an MPSolver\
\
Before you can build any part of your optimization model, you need an `MPSolver` object. You create one using a static method: `MPSolver.createSolver()`.\
\
This method requires you to specify which specific *backend solver* you want to use. Different solvers are good at different types of problems or have varying performance characteristics. For simple Linear Programming problems (like the one in our `BasicExample.java`), OR-Tools provides a few options. A common and freely available one is called "GLOP".\
\
Let's look at the code from `BasicExample.java` for creating the solver:\
\
```java\
// [START solver]\
// Create the linear solver with the GLOP backend.\
MPSolver solver = MPSolver.createSolver("GLOP");\
if (solver == null) \{\
  System.out.println("Could not create solver GLOP");\
  return; // Handle case where solver creation fails\
\}\
// [END solver]\
```\
\
*   `MPSolver.createSolver("GLOP")`: This is the key call. It asks OR-Tools to give you an `MPSolver` instance configured to use the "GLOP" algorithm.\
*   The method returns an `MPSolver` object if successful, or `null` if it couldn't create the requested solver (e.g., if the solver name is misspelled or not available). It's good practice to check for `null`.\
\
This single line (`MPSolver.createSolver("GLOP");`) initializes the powerful OR-Tools engine and prepares it to receive your problem definition.\
\
## Building the Model with the MPSolver\
\
Once you have your `solver` object, you use its methods to add variables, constraints, and define the objective function. The `MPSolver` object acts like a factory for these components.\
\
Here's how the `BasicExample.java` code uses the `solver` object to define the problem: Maximize `3x + y` subject to `0 <= x <= 1`, `0 <= y <= 2`, and `x + y <= 2`.\
\
First, creating variables:\
\
```java\
// [START variables]\
// Create the variables x and y.\
MPVariable x = solver.makeNumVar(0.0, 1.0, "x");\
MPVariable y = solver.makeNumVar(0.0, 2.0, "y");\
\
System.out.println("Number of variables = " + solver.numVariables());\
// [END variables]\
```\
\
*   `solver.makeNumVar(...)`: This method of the `solver` object creates a continuous numerical variable. We'll learn more about `MPVariable` in the next chapter, but for now, notice that it's the `solver` object that provides the means to create it.\
\
Next, creating constraints:\
\
```java\
// [START constraints]\
double infinity = java.lang.Double.POSITIVE_INFINITY;\
// Create a linear constraint, x + y <= 2.\
MPConstraint ct = solver.makeConstraint(-infinity, 2.0, "ct");\
ct.setCoefficient(x, 1);\
ct.setCoefficient(y, 1);\
\
System.out.println("Number of constraints = " + solver.numConstraints());\
// [END constraints]\
```\
\
*   `solver.makeConstraint(...)`: Similarly, the `solver` object creates `MPConstraint` objects. You then use the methods on the `MPConstraint` object (`ct.setCoefficient(...)`) to define the specific relationship between variables.\
\
Finally, setting the objective function:\
\
```java\
// [START objective]\
// Create the objective function, 3 * x + y.\
MPObjective objective = solver.objective();\
objective.setCoefficient(x, 3);\
objective.setCoefficient(y, 1);\
objective.setMaximization();\
// [END objective]\
```\
\
*   `solver.objective()`: The `solver` object provides access to a unique `MPObjective` object that represents the function you want to maximize or minimize.\
\
So, the `MPSolver` is not just created; it's actively used to build the entire problem structure piece by piece by calling its `make...` methods.\
\
## Solving the Problem\
\
Once all variables, constraints, and the objective are added to the `MPSolver`, you tell it to find the solution. This is done with the `solve()` method:\
\
```java\
// [START solve]\
System.out.println("Solving with " + solver.solverVersion());\
final MPSolver.ResultStatus resultStatus = solver.solve();\
// [END solve]\
```\
\
*   `solver.solve()`: This is the command that triggers the optimization algorithm (GLOP in our case) to run. It takes the problem definition collected by the `solver` object and finds the values for the variables that best meet the objective without violating any constraints.\
*   The method returns an `MPSolver.ResultStatus`. This status tells you if an optimal solution was found (`OPTIMAL`), if the problem is impossible (`INFEASIBLE`), if the objective can be infinitely improved (`UNBOUNDED`), or if the solver stopped for other reasons.\
\
## Getting the Solution\
\
After `solver.solve()` finishes and returns a status indicating a solution was found (typically `OPTIMAL` or `FEASIBLE`), you can query the `solver` and the objects it created (`MPVariable`, `MPObjective`) to get the results.\
\
```java\
// [START print_solution]\
System.out.println("Status: " + resultStatus);\
if (resultStatus == MPSolver.ResultStatus.OPTIMAL) \{\
    System.out.println("Solution:");\
    System.out.println("Objective value = " + objective.value());\
    System.out.println("x = " + x.solutionValue());\
    System.out.println("y = " + y.solutionValue());\
\} else \{\
    System.out.println("The problem does not have an optimal solution.");\
\}\
// [END print_solution]\
```\
\
*   `objective.value()`: Called on the `MPObjective` object obtained from the `solver`, this gives you the optimal value of the objective function found by the solver.\
*   `x.solutionValue()` and `y.solutionValue()`: Called on the `MPVariable` objects created by the `solver`, these methods give you the optimal numerical values OR-Tools found for variables `x` and `y`.\
\
## Minimal Example: Maximize a Single Variable\
\
Let's strip down the `BasicExample` to the absolute minimum to see just the `MPSolver` in action with one variable and one constraint.\
\
Problem: Maximize `x` subject to `0 <= x <= 5` and `x <= 2`.\
\
```java\
import com.google.ortools.Loader;\
import com.google.ortools.linearsolver.MPConstraint;\
import com.google.ortools.linearsolver.MPObjective;\
import com.google.ortools.linearsolver.MPSolver;\
import com.google.ortools.linearsolver.MPVariable;\
\
public class MinimalSolverExample \{\
    public static void main(String[] args) \{\
        Loader.loadNativeLibraries(); // Load OR-Tools\
\
        // 1. Create the solver\
        MPSolver solver = MPSolver.createSolver("GLOP");\
        if (solver == null) \{\
            System.err.println("Could not create solver.");\
            return;\
        \}\
        System.out.println("Solver created.");\
\
        // 2. Create variables using the solver\
        MPVariable x = solver.makeNumVar(0.0, 5.0, "x");\
        System.out.println("Variable x created.");\
\
        // 3. Create constraint using the solver\
        MPConstraint c1 = solver.makeConstraint(-MPSolver.infinity(), 2.0, "limit_x");\
        c1.setCoefficient(x, 1);\
        System.out.println("Constraint x <= 2 created.");\
\
        // 4. Get the objective using the solver\
        MPObjective objective = solver.objective();\
        objective.setCoefficient(x, 1); // Maximize 1*x\
        objective.setMaximization();\
        System.out.println("Objective to maximize x created.");\
\
        // 5. Solve the problem\
        MPSolver.ResultStatus status = solver.solve();\
        System.out.println("Problem solved.");\
\
        // 6. Print the solution\
        if (status == MPSolver.ResultStatus.OPTIMAL) \{\
            System.out.println("Solution:");\
            System.out.println("Objective value = " + objective.value()); // Expected: 2.0\
            System.out.println("x = " + x.solutionValue()); // Expected: 2.0\
        \} else \{\
            System.out.println("Problem did not have an optimal solution. Status: " + status);\
        \}\
    \}\
\}\
```\
\
Running this code (e.g., using `mvn exec:java` if set up in `pom.xml`) would produce output similar to:\
\
```\
Google OR-Tools version: ...\
Solver created.\
Variable x created.\
Constraint x <= 2 created.\
Objective to maximize x created.\
Solving with GLOP ...\
Problem solved.\
Solution:\
Objective value = 2.0\
x = 2.0\
```\
\
This minimal example shows the core flow: get a `MPSolver`, use it to make your model pieces, tell it to solve, and then ask for results.\
\
## How MPSolver Works Under the Hood (Simple View)\
\
When you interact with the `MPSolver` object in Java, you are essentially communicating with the underlying OR-Tools native C++ code and the chosen solver algorithm (like GLOP). The `MPSolver` object in Java acts as a translator and manager.\
\
Here's a simplified sequence:\
\
```mermaid\
sequenceDiagram\
    participant YourJavaApp\
    participant MPSolverJavaObj["MPSolver Object (Java)"]\
    participant OrToolsNativeCode["OR-Tools Native Code (C++)"]\
    participant GlopSolver["GLOP Solver Algorithm"]\
\
    YourJavaApp->>MPSolverJavaObj: MPSolver.createSolver("GLOP")\
    MPSolverJavaObj->>OrToolsNativeCode: Initialize GLOP solver interface\
    OrToolsNativeCode-->>MPSolverJavaObj: Indicate success\
    MPSolverJavaObj-->>YourJavaApp: Return MPSolver object\
\
    YourJavaApp->>MPSolverJavaObj: solver.makeNumVar(...)\
    MPSolverJavaObj->>OrToolsNativeCode: Add variable definition\
    Note over OrToolsNativeCode: Internal model representation updated\
\
    YourJavaApp->>MPSolverJavaObj: solver.makeConstraint(...)\
    MPSolverJavaObj->>OrToolsNativeCode: Add constraint definition\
    Note over OrToolsNativeCode: Internal model representation updated\
\
    YourJavaApp->>MPSolverJavaObj: solver.objective().setCoefficient(...)\
    MPSolverJavaObj->>OrToolsNativeCode: Set objective details\
    Note over OrToolsNativeCode: Internal model representation updated\
\
    YourJavaApp->>MPSolverJavaObj: solver.solve()\
    MPSolverJavaObj->>OrToolsNativeCode: Trigger solve process\
    OrToolsNativeCode->>GlopSolver: Pass internal model to algorithm\
    GlopSolver-->>OrToolsNativeCode: Return solution found\
\
    OrToolsNativeCode-->>MPSolverJavaObj: Pass solution results back\
    MPSolverJavaObj-->>YourJavaApp: Return ResultStatus\
\
    YourJavaApp->>MPSolverJavaObj: variable.solutionValue()\
    MPSolverJavaObj->>OrToolsNativeCode: Request variable's solved value\
    OrToolsNativeCode-->>MPSolverJavaObj: Return value\
    MPSolverJavaObj-->>YourJavaApp: Return value\
\
    YourJavaApp->>MPSolverJavaObj: objective.value()\
    MPSolverJavaObj->>OrToolsNativeCode: Request objective's solved value\
    OrToolsNativeCode-->>MPSolverJavaObj: Return value\
    MPSolverJavaObj-->>YourJavaApp: Return value\
```\
\
Essentially, the `MPSolver` Java object serves as the bridge. You call its methods, it communicates with the lower-level OR-Tools code which manages the actual mathematical model and interacts with the chosen solver backend (like GLOP). The results are then passed back up through the same bridge.\
\
## Choosing a Solver Backend\
\
As mentioned, `MPSolver.createSolver()` takes a string argument for the solver backend. Here are a few common ones for Linear Programming problems:\
\
| Solver Name | Description                                                                 | Availability        |\
| :---------- | :-------------------------------------------------------------------------- | :------------------ |\
| `"GLOP"`    | Google's own Linear Programming solver. Generally fast and robust.          | Included by default |\
| `"CBC"`     | Coin-or Branch and Cut. A popular open-source mixed-integer programming solver that also solves LPs. | Included by default |\
| `"CLP"`     | Coin-or Linear Programming. Another open-source LP solver.                | Included by default |\
| `"SCIP"`    | A powerful non-commercial solver for mixed-integer programming.           | Requires separate build config in OR-Tools |\
| `"CPLEX"`, `"GUROBI"` | Commercial, high-performance solvers.                              | Requires licenses and separate build config |\
\
For simple LP problems like our example, "GLOP" is a great default choice and is always available when using the standard `ortools-java` library.\
\
## Summary\
\
In this chapter, we focused on the `MPSolver`. We learned it's the core object in OR-Tools for defining and solving Linear Programming problems. You create an `MPSolver` by specifying a backend solver name like "GLOP". This `MPSolver` object then acts as the factory and container for the rest of your model components (`MPVariable`, `MPConstraint`, `MPObjective`). Once the model is built, you call `solver.solve()` to find the solution, and then retrieve results using methods like `variable.solutionValue()` and `objective.value()`.\
\
Understanding the `MPSolver` is crucial, as it's the starting point for any LP problem in OR-Tools. Now that we know where to start, let's look at the first piece we add to the solver: the variable, represented by `MPVariable`.\
\
[Chapter 4: MPVariable](04_mpvariable_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/src/main/java/org/or_tools/example/BasicExample.java)</sup></sub>\
\
# Chapter 4: MPVariable\
\
Welcome back! In [Chapter 3: MPSolver](03_mpsolver_.md), we learned that the `MPSolver` is the central object in OR-Tools that acts as our mathematical programming engine. It's what we use to create and solve optimization problems.\
\
But what exactly goes *into* the `MPSolver`? What are the fundamental building blocks we use to describe our problem? The first and most important building block is the **variable**.\
\
## What is an MPVariable?\
\
Think about the basic optimization problem we saw in [Chapter 1](01_google_or_tools_library__ortools_java__.md) and used with the `MPSolver` in [Chapter 3](03_mpsolver_.md):\
\
Maximize `3x + y`\
Subject to:\
`x + y <= 2`\
`0 <= x <= 1`\
`0 <= y <= 2`\
\
In this problem, `x` and `y` are the things we need to figure out. Their values are currently *unknown*, and the goal of the solver is to find the *best* values for `x` and `y` that satisfy the rules and make `3x + y` as large as possible.\
\
In the world of OR-Tools, these unknown numerical values are represented by the `MPVariable` object.\
\
An `MPVariable` represents a single decision variable in your optimization problem. It's a numerical value that the `MPSolver` will try to assign a specific number to during the solving process.\
\
Key characteristics of an `MPVariable`:\
\
*   **It's unknown initially:** You create it, but its optimal value is determined by the solver.\
*   **It has bounds:** You must define a **lower bound** and an **upper bound**. The solver is *only* allowed to assign a value to the variable that falls within this range (inclusive). For our example, `x` is bounded between 0 and 1, and `y` is bounded between 0 and 2.\
*   **It has a name (optional but recommended):** Giving variables names like "x", "y", "unitsProduced", "employeeShift" makes your code easier to read and helps when interpreting the results.\
\
Imagine you have a dial for each variable. The dial can only point to values between its lower and upper bounds. The solver's job is to find the position for each dial that works best according to your rules and objective.\
\
## Creating MPVariables\
\
You create `MPVariable` objects using the `MPSolver` object we learned about in the last chapter. The `MPSolver` has methods specifically for this purpose. For continuous numerical variables (like `x` and `y` in our example, which can be any number between their bounds, including decimals), you use the `makeNumVar` method.\
\
Here's how `x` and `y` are created in the `BasicExample.java` code:\
\
```java\
// [START variables]\
// Create the variables x and y.\
MPVariable x = solver.makeNumVar(0.0, 1.0, "x");\
MPVariable y = solver.makeNumVar(0.0, 2.0, "y");\
\
System.out.println("Number of variables = " + solver.numVariables());\
// [END variables]\
```\
\
Let's break down `solver.makeNumVar(0.0, 1.0, "x");`:\
\
*   `solver`: This is our `MPSolver` object, obtained from `MPSolver.createSolver()`. It's the factory for creating model components.\
*   `.makeNumVar()`: This method tells the solver to create a new continuous numerical variable.\
*   `0.0`: This is the **lower bound**. The value of `x` must be greater than or equal to 0.0.\
*   `1.0`: This is the **upper bound**. The value of `x` must be less than or equal to 1.0.\
*   `"x"`: This is the **name** of the variable.\
\
The line `MPVariable x = ...` captures the newly created variable object and assigns it to a Java variable named `x`. You'll use this `x` object later to refer to this specific variable when defining constraints and the objective.\
\
Similarly, `solver.makeNumVar(0.0, 2.0, "y");` creates a variable `y` with a lower bound of 0.0 and an upper bound of 2.0.\
\
After creating the variables, `System.out.println("Number of variables = " + solver.numVariables());` is just a helper line to show that the solver object now knows about these two variables.\
\
### Other Variable Types (Briefly)\
\
While `makeNumVar` is for continuous variables, OR-Tools also supports:\
\
*   `makeIntVar(lowerBound, upperBound, name)`: For **integer** variables (variables that can only take whole number values within the bounds). Useful for problems where decisions must be discrete (e.g., number of items to produce, which must be a whole number).\
*   `makeBoolVar(name)`: A special case of integer variable that can only take values 0 or 1 (**boolean** or binary variable). Useful for 'yes/no' decisions (e.g., whether to open a factory at a specific location).\
\
For the basic example in this project, we only need `makeNumVar`.\
\
## Using MPVariables in Constraints and Objectives\
\
Once you've created your `MPVariable` objects, you use them when defining the rules (constraints) and what you want to optimize (the objective) with the `MPSolver`.\
\
Remember the constraint `x + y <= 2` from our example? We saw in [Chapter 3](03_mpsolver_.md) that we create an `MPConstraint` object using `solver.makeConstraint()`. But how do we tell the constraint *which* variables are involved and with what numbers (coefficients)?\
\
We use the `MPVariable` objects we created:\
\
```java\
// [START constraints]\
double infinity = java.lang.Double.POSITIVE_INFINITY;\
// Create a linear constraint, x + y <= 2.\
MPConstraint ct = solver.makeConstraint(-infinity, 2.0, "ct");\
ct.setCoefficient(x, 1); // Use variable x with coefficient 1\
ct.setCoefficient(y, 1); // Use variable y with coefficient 1\
\
System.out.println("Number of constraints = " + solver.numConstraints());\
// [END constraints]\
```\
\
Here, `ct.setCoefficient(x, 1);` tells the constraint `ct` that the variable `x` is part of this constraint and has a coefficient of 1. The constraint is building the expression `1 * x + 1 * y`.\
\
Similarly, for the objective function `Maximize 3x + y`:\
\
```java\
// [START objective]\
// Create the objective function, 3 * x + y.\
MPObjective objective = solver.objective();\
objective.setCoefficient(x, 3); // Use variable x with coefficient 3 in objective\
objective.setCoefficient(y, 1); // Use variable y with coefficient 1 in objective\
objective.setMaximization();\
// [END objective]\
```\
\
`objective.setCoefficient(x, 3);` tells the objective object that variable `x` is included in the objective function with a coefficient of 3.\
\
These snippets show how the `MPVariable` objects serve as references to the actual variables within the solver's model.\
\
## Getting the Solution Value\
\
After you call `solver.solve()`, the `MPSolver` does its magic and finds the optimal values for all the variables. You can then ask each `MPVariable` object what its final, optimal value is using the `solutionValue()` method.\
\
Looking back at the end of `BasicExample.java`:\
\
```java\
// [START print_solution]\
// ... check resultStatus ...\
\
System.out.println("Solution:");\
System.out.println("Objective value = " + objective.value());\
System.out.println("x = " + x.solutionValue()); // Get the solved value for x\
System.out.println("y = " + y.solutionValue()); // Get the solved value for y\
// [END print_solution]\
```\
\
`x.solutionValue()` returns the numerical value that the solver assigned to the variable `x` to achieve the optimal solution (which was 1.0 in our example). `y.solutionValue()` does the same for `y` (which was also 1.0).\
\
## MPVariable Under the Hood (Simple View)\
\
When you call `solver.makeNumVar(...)`, you create a Java object (`MPVariable`). This Java object is essentially a lightweight handle or reference. Its main job is to communicate with the underlying OR-Tools native code (written in C++).\
\
```mermaid\
sequenceDiagram\
    participant YourJavaApp\
    participant MPSolverJavaObj["MPSolver Object (Java)"]\
    participant MPVariableJavaObj["MPVariable Object (Java)"]\
    participant OrToolsNativeCode["OR-Tools Native Code (C++)"]\
\
    YourJavaApp->>MPSolverJavaObj: solver.makeNumVar(0.0, 1.0, "x")\
    MPSolverJavaObj->>OrToolsNativeCode: Request new variable (lower=0.0, upper=1.0, name="x")\
    Note over OrToolsNativeCode: Creates internal representation<br/>for variable 'x', stores bounds.\
    OrToolsNativeCode-->>MPSolverJavaObj: Return internal ID/pointer for the new variable\
    MPSolverJavaObj->>MPVariableJavaObj: Create new MPVariable Java object,<br/>store the internal ID\
    MPVariableJavaObj-->>YourJavaApp: Return MPVariable Java object (assigned to 'x')\
\
    YourJavaApp->>MPSolverJavaObj: solver.makeNumVar(0.0, 2.0, "y")\
    MPSolverJavaObj->>OrToolsNativeCode: Request new variable (lower=0.0, upper=2.0, name="y")\
    Note over OrToolsNativeCode: Creates internal representation<br/>for variable 'y', stores bounds.\
    OrToolsNativeCode-->>MPSolverJavaObj: Return internal ID/pointer for the new variable\
    MPSolverJavaObj->>MPVariableJavaObj: Create new MPVariable Java object,<br/>store the internal ID\
    MPVariableJavaObj-->>YourJavaApp: Return MPVariable Java object (assigned to 'y')\
\
    Note over YourJavaApp: Later, when calling methods like<br/>variable.solutionValue()...\
\
    YourJavaApp->>MPVariableJavaObj: x.solutionValue()\
    MPVariableJavaObj->>OrToolsNativeCode: Use stored ID to request<br/>the solved value for 'x'\
    OrToolsNativeCode-->>MPVariableJavaObj: Return solved value (e.g., 1.0)\
    MPVariableJavaObj-->>YourJavaApp: Return solved value\
```\
\
When you create an `MPVariable` via `makeNumVar` (or `makeIntVar`/`makeBoolVar`), the `MPSolver` object tells the core OR-Tools library (the native code) to create an internal representation of that variable. This internal representation stores the bounds and other properties. The Java `MPVariable` object you get back simply holds a reference (like a unique ID or a pointer) to this internal representation.\
\
When you use the `MPVariable` object later, for instance, in `ct.setCoefficient(x, 1)`, the `MPConstraint` object uses the reference inside the Java `x` object to tell the native code *which* variable the coefficient 1 applies to.\
\
When you call `solver.solve()`, the solver algorithm works directly with these internal native representations of variables, constraints, and objectives.\
\
After the solver finds a solution, the optimal values for each variable are stored in their internal native representations. When you call `x.solutionValue()`, the Java `MPVariable` object `x` uses its stored reference to ask the native code for the solved value of the variable it represents, and that value is then returned to your Java code.\
\
This separation between the Java object (your handle) and the native representation (where the real work happens) is common in libraries like OR-Tools that wrap high-performance code written in languages like C++.\
\
## Summary\
\
In this chapter, we explored the `MPVariable`. We learned that it represents the unknown numerical decisions or quantities in our optimization problem, much like variables 'x' and 'y' in algebra. We saw how to create continuous variables using the `MPSolver`'s `makeNumVar` method, specifying their essential lower and upper bounds. We also saw how these `MPVariable` objects are used as references when defining constraints and the objective function, and how to retrieve their final optimal values after the solver runs using the `solutionValue()` method.\
\
With the `MPSolver` as our engine and `MPVariable` as our decision-making building blocks, we are ready to look at the rules that these variables must follow: the constraints.\
\
[Chapter 5: MPConstraint](05_mpconstraint_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/src/main/java/org/or_tools/example/BasicExample.java)</sup></sub>\
\
# Chapter 5: MPConstraint\
\
Welcome back! In [Chapter 4: MPVariable](04_mpvariable_.md), we learned about `MPVariable`, which represents the unknown numerical decisions or quantities in our optimization problem \'96 the values the solver needs to figure out. We saw how to create these variables using the `MPSolver` object and define their basic lower and upper limits.\
\
But what good are variables if they can take *any* value? Optimization problems always have rules, limitations, or conditions that the variables must satisfy. For example, if `x` is the number of chairs and `y` is the number of tables, you might have a limit on the total wood available, leading to a rule like "wood for chairs + wood for tables <= total wood".\
\
In OR-Tools, these rules are represented by the **`MPConstraint`** object.\
\
## What is an MPConstraint?\
\
An `MPConstraint` defines a linear relationship between variables that must hold true. This relationship is typically an **inequality** (less than or equal to `<=`, or greater than or equal to `>=`) or an **equality** (`==`).\
\
Think of constraints as fences or boundaries in the solution space. The solver is only allowed to pick values for the variables that are *within* or *on* these boundaries, simultaneously satisfying *all* the constraints.\
\
For our running example:\
\
Maximize `3x + y`\
Subject to:\
`x + y <= 2`\
`0 <= x <= 1` (These are variable bounds, often handled when creating the `MPVariable`)\
`0 <= y <= 2` (These are also variable bounds)\
\
The rule `x + y <= 2` is the core linear constraint we need to represent using an `MPConstraint` object. It states that the sum of the values of variables `x` and `y` cannot exceed 2.\
\
An `MPConstraint` object in OR-Tools:\
\
*   Represents a single linear equation or inequality involving one or more `MPVariable` objects.\
*   Requires you to specify the **lower bound** and **upper bound** for the *result* of the linear expression.\
*   Allows you to add `MPVariable` objects to it with specific **coefficients** (the numbers that multiply the variables, like the '1' in `1*x` or `1*y`).\
\
It's like saying, "Take `x` and multiply it by something, take `y` and multiply it by something else, add them up, and the total must be between this minimum number and this maximum number."\
\
## Creating MPConstraints\
\
Like `MPVariable` objects, you create `MPConstraint` objects using the `MPSolver` object. The specific method is `makeConstraint()`.\
\
The `makeConstraint` method takes arguments that define the bounds for the linear expression you will build within the constraint:\
\
```java\
// [START constraints]\
double infinity = java.lang.Double.POSITIVE_INFINITY;\
// Create a linear constraint, x + y <= 2.\
// This constraint requires the expression (x + y)\
// to be >= -infinity and <= 2.0.\
MPConstraint ct = solver.makeConstraint(-infinity, 2.0, "ct");\
\
// The constraint object 'ct' is now created, but it's empty.\
// We need to add variables and their coefficients to it next.\
\
System.out.println("Number of constraints = " + solver.numConstraints());\
// [END constraints]\
```\
\
Let's break down `solver.makeConstraint(-infinity, 2.0, "ct");`:\
\
*   `solver`: Our trusty `MPSolver` object.\
*   `.makeConstraint()`: The method to create a new constraint.\
*   `-infinity`: This is the **lower bound** for the linear expression we're about to build (`x + y`). Using `-infinity` means there's no effective lower limit on the sum, which is typical for a '<= something' inequality. OR-Tools provides `MPSolver.infinity()` (which uses `Double.POSITIVE_INFINITY`) for convenience.\
*   `2.0`: This is the **upper bound** for the linear expression (`x + y`). This enforces the '... <= 2.0' part of the constraint. The sum `x + y` *must* be less than or equal to 2.0.\
*   `"ct"`: An optional but recommended **name** for the constraint. It helps in identifying constraints, especially when debugging.\
\
So, creating the `MPConstraint` object itself defines the allowable *range* for the linear expression it will contain.\
\
## Adding Variables and Coefficients\
\
Once you have the `MPConstraint` object (`ct` in our example), you use its `setCoefficient()` method to specify which variables are part of this constraint and what number they are multiplied by (their coefficient).\
\
Continuing from the previous step:\
\
```java\
// 'ct' was created as: solver.makeConstraint(-infinity, 2.0, "ct");\
\
// Add variables and coefficients to the constraint 'ct'.\
// The constraint represents: 1*x + 1*y\
ct.setCoefficient(x, 1); // Add variable x with coefficient 1\
ct.setCoefficient(y, 1); // Add variable y with coefficient 1\
\
// Now, the constraint 'ct' represents: -infinity <= (1*x + 1*y) <= 2.0\
// This is equivalent to: x + y <= 2.0\
```\
\
*   `ct`: The `MPConstraint` object we just created.\
*   `.setCoefficient(x, 1);`: This method takes an `MPVariable` object (`x`) and a `double` value (`1`). It tells the constraint `ct` to include the term `1 * x` in its linear expression.\
*   `.setCoefficient(y, 1);`: Similarly, this adds the term `1 * y` to the constraint `ct`.\
\
After these calls, the `MPConstraint` object `ct` correctly represents the inequality `x + y <= 2`. The full mathematical representation collected by the solver for this constraint is `lowerBound <= (coefficient_x * x + coefficient_y * y + ...) <= upperBound`. In our case: `-infinity <= (1 * x + 1 * y) <= 2.0`.\
\
## Representing Different Types of Constraints\
\
By adjusting the lower and upper bounds provided to `makeConstraint()` and the coefficients with `setCoefficient()`, you can represent various linear constraints:\
\
*   **Less than or equal to (`<=`):**\
    *   Expression `E <= RHS`\
    *   Use `solver.makeConstraint(-infinity, RHS, "name");`\
    *   Add terms for `E` using `setCoefficient()`.\
    *   Example (`x + y <= 2`): `solver.makeConstraint(-infinity, 2.0, "ct"); ct.setCoefficient(x, 1); ct.setCoefficient(y, 1);`\
\
*   **Greater than or equal to (`>=`):**\
    *   Expression `E >= LHS`\
    *   Use `solver.makeConstraint(LHS, infinity, "name");`\
    *   Add terms for `E` using `setCoefficient()`.\
    *   Example (`2x - y >= 5`): `solver.makeConstraint(5.0, infinity, "ct2"); ct2.setCoefficient(x, 2); ct2.setCoefficient(y, -1);`\
\
*   **Equality (`==`):**\
    *   Expression `E == Value`\
    *   Use `solver.makeConstraint(Value, Value, "name");` (Set both lower and upper bound to the same value).\
    *   Add terms for `E` using `setCoefficient()`.\
    *   Example (`x + 2y == 10`): `solver.makeConstraint(10.0, 10.0, "ct3"); ct3.setCoefficient(x, 1); ct3.setCoefficient(y, 2);`\
\
*   **Range Constraint (`LHS <= E <= RHS`):**\
    *   Use `solver.makeConstraint(LHS, RHS, "name");`\
    *   Add terms for `E` using `setCoefficient()`.\
    *   Example (`5 <= 2x + y <= 10`): `solver.makeConstraint(5.0, 10.0, "ct4"); ct4.setCoefficient(x, 2); ct4.setCoefficient(y, 1);`\
\
The flexibility comes from setting the bounds of the `MPConstraint` object and then defining the linear expression using `setCoefficient()` with your `MPVariable` objects.\
\
## MPConstraint Under the Hood (Simple View)\
\
Similar to `MPVariable`, the `MPConstraint` object you manipulate in Java is a handle to an internal representation managed by the OR-Tools native code.\
\
When you call `solver.makeConstraint(...)`, the Java `MPSolver` tells the native code to create a new constraint structure. This structure internally stores the lower and upper bounds you provided.\
\
```mermaid\
sequenceDiagram\
    participant YourJavaApp\
    participant MPSolverJavaObj["MPSolver Object (Java)"]\
    participant MPConstraintJavaObj["MPConstraint Object (Java)"]\
    participant OrToolsNativeCode["OR-Tools Native Code (C++)"]\
    participant MPVariableJavaObjX["MPVariable 'x' (Java)"]\
    participant MPVariableJavaObjY["MPVariable 'y' (Java)"]\
\
    YourJavaApp->>MPSolverJavaObj: solver.makeConstraint(-inf, 2.0, "ct")\
    MPSolverJavaObj->>OrToolsNativeCode: Request new constraint (lower=-inf, upper=2.0, name="ct")\
    Note over OrToolsNativeCode: Creates internal representation<br/>for constraint 'ct', stores bounds.\
    OrToolsNativeCode-->>MPSolverJavaObj: Return internal ID/pointer for the new constraint\
    MPSolverJavaObj->>MPConstraintJavaObj: Create new MPConstraint Java object,<br/>store the internal ID\
    MPConstraintJavaObj-->>YourJavaApp: Return MPConstraint Java object (assigned to 'ct')\
\
    Note over YourJavaApp: 'x' and 'y' are existing MPVariable objects<br/>holding their own native IDs.\
\
    YourJavaApp->>MPConstraintJavaObj: ct.setCoefficient(x, 1)\
    MPConstraintJavaObj->>MPVariableJavaObjX: Get internal ID for 'x'\
    MPVariableJavaObjX-->>MPConstraintJavaObj: Return internal ID of 'x'\
    MPConstraintJavaObj->>OrToolsNativeCode: Tell constraint 'ct' (using its ID):<br/>Add variable with ID of 'x' and coefficient 1.0\
    Note over OrToolsNativeCode: Updates internal constraint structure.\
\
    YourJavaApp->>MPConstraintJavaObj: ct.setCoefficient(y, 1)\
    MPConstraintJavaObj->>MPVariableJavaObjY: Get internal ID for 'y'\
    MPVariableJavaObjY-->>MPConstraintJavaObj: Return internal ID of 'y'\
    MPConstraintJavaObj->>OrToolsNativeCode: Tell constraint 'ct' (using its ID):<br/>Add variable with ID of 'y' and coefficient 1.0\
    Note over OrToolsNativeCode: Updates internal constraint structure.\
\
    Note over OrToolsNativeCode: Now constraint 'ct' internally represents<br/>(-inf <= 1*x + 1*y <= 2.0).\
```\
\
When you call `ct.setCoefficient(x, 1)`, the `MPConstraint` object `ct` uses the internal ID stored within the `MPVariable` object `x` to tell the native code *which* variable to associate with the coefficient 1 for this specific constraint. The native code then updates the internal representation of the constraint.\
\
When `solver.solve()` is called, the chosen solver algorithm (like GLOP) works directly with these interconnected native representations of variables, constraints, and the objective function to find values for the variables that satisfy all the constraint bounds.\
\
## Summary\
\
In this chapter, we focused on the `MPConstraint`. We learned that it is the OR-Tools object used to define the linear rules and limitations that `MPVariable` values must obey. We saw how to create a constraint using `MPSolver.makeConstraint()`, specifying the lower and upper bounds for the linear expression. Crucially, we learned how to use the `setCoefficient()` method on the `MPConstraint` object, passing in `MPVariable` objects and their corresponding numerical coefficients to build the actual linear equation or inequality. By combining `makeConstraint()` with appropriate bounds and `setCoefficient()` calls, we can represent `<=`, `>=`, `==`, and range constraints.\
\
With the `MPSolver` as our engine, `MPVariable`s as our decisions, and `MPConstraint`s as our rules, we have almost everything needed to define an optimization problem. The final piece is telling the solver what we want to maximize or minimize \'96 the objective function.\
\
[Chapter 6: MPObjective](06_mpobjective_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/src/main/java/org/or_tools/example/BasicExample.java)</sup></sub>\
\
\
# Chapter 6: MPObjective\
\
Welcome back! Over the last few chapters, we've built the foundation of our optimization problem:\
\
*   In [Chapter 3: MPSolver](03_mpsolver_.md), we learned that the `MPSolver` is the central engine we use to build and solve problems.\
*   In [Chapter 4: MPVariable](04_mpvariable_.md), we saw how `MPVariable` represents the decisions or unknown quantities (like `x` and `y`) that the solver needs to find values for.\
*   In [Chapter 5: MPConstraint](05_mpconstraint_.md), we learned how `MPConstraint` defines the rules or limitations (like `x + y <= 2`) that the variables must obey.\
\
Now, we have variables (`MPVariable`) that are constrained by rules (`MPConstraint`), but what are we actually trying to *do* with them? What's the goal? Are we trying to make a certain value as big as possible, or as small as possible?\
\
This goal is defined by the **objective function**, and in OR-Tools, it's represented by the **`MPObjective`** object.\
\
## What is the MPObjective?\
\
In an optimization problem, the objective function is the mathematical expression you want to either **maximize** or **minimize**. It's the score you're trying to make as high (for maximization) or as low (for minimization) as possible.\
\
For our running example:\
\
**Maximize** `3x + y`\
Subject to:\
`x + y <= 2`\
`0 <= x <= 1`\
`0 <= y <= 2`\
\
The expression `3x + y` is the objective function. Our goal is to find values for `x` and `y` (that satisfy the constraints) such that the result of `3x + y` is the largest possible number.\
\
The `MPObjective` object in OR-Tools is where you define this expression (`3x + y` in our case) and specify whether you want to maximize or minimize it.\
\
Key things about the `MPObjective`:\
\
*   It represents a **linear combination** of your `MPVariable`s, meaning each variable is multiplied by a constant (its coefficient), and these terms are added together (e.g., `3*x + 1*y`).\
*   There is typically **only one** objective function for the entire problem being solved by an `MPSolver`.\
*   You specify whether the goal is **maximization** or **minimization**.\
\
Think of the objective as the score-keeping rule. For every possible combination of `x` and `y` values that satisfies the constraints, you calculate the "score" using the objective function (`3*x + 1*y`). The solver's job is to find the combination of `x` and `y` that gives the best score (highest for maximization, lowest for minimization).\
\
## Getting the MPObjective Object\
\
Unlike variables and constraints that you `make...` using the `MPSolver`, there's usually only one objective associated with a solver. You get access to this single `MPObjective` object by calling the `objective()` method on your `MPSolver` instance.\
\
Here's the relevant code from `BasicExample.java`:\
\
```java\
// [START objective]\
// Create the objective function, 3 * x + y.\
// Get the objective object from the solver.\
MPObjective objective = solver.objective();\
\
// Now that we have the 'objective' object, we define the expression\
// and whether to maximize/minimize it using methods on this object.\
// [END objective]\
```\
\
*   `solver.objective()`: This method is called on our `MPSolver` object (`solver`) and returns the `MPObjective` object associated with this solver.\
*   `MPObjective objective = ...`: We store the returned `MPObjective` object in a Java variable named `objective`. We will use this variable to configure the objective function.\
\
## Defining the Objective Expression\
\
Just like with `MPConstraint`, you define the linear expression for the objective by adding variables (`MPVariable`) and their multiplying constants (coefficients) using the `setCoefficient()` method.\
\
Continuing from where we got the `objective` object:\
\
```java\
// 'objective' was obtained via solver.objective();\
\
// Define the expression 3 * x + 1 * y\
objective.setCoefficient(x, 3); // Add variable x with coefficient 3\
objective.setCoefficient(y, 1); // Add variable y with coefficient 1\
\
// The objective expression is now set as 3*x + 1*y\
```\
\
*   `objective.setCoefficient(x, 3);`: This tells the `objective` that the variable `x` is part of the objective expression and is multiplied by the number `3`.\
*   `objective.setCoefficient(y, 1);`: This tells the `objective` that the variable `y` is part of the objective expression and is multiplied by the number `1`.\
\
After these two calls, the `objective` object internally represents the expression `3*x + 1*y`.\
\
## Setting Maximization or Minimization\
\
The final piece of defining the objective is telling the solver whether you want to find the largest possible value for the expression or the smallest. You do this using the `setMaximization()` or `setMinimization()` methods on the `MPObjective` object.\
\
For our example, we want to maximize `3x + y`:\
\
```java\
// 'objective' expression was set up with setCoefficient() calls.\
\
// Tell the solver to maximize this objective expression.\
objective.setMaximization();\
\
// If we wanted to minimize it instead, we would use:\
// objective.setMinimization();\
\
// The objective is now fully defined!\
// [END objective]\
```\
\
*   `objective.setMaximization();`: This method sets the goal to finding the maximum possible value of the objective expression that satisfies all constraints.\
*   `objective.setMinimization();`: You would use this instead if your goal was to find the minimum possible value.\
\
Once these steps are done, the `MPSolver` knows exactly what variables are involved, what rules they must follow (`MPConstraint`s), and what function it needs to optimize (`MPObjective`), and in which direction (maximize/minimize).\
\
## Getting the Optimal Objective Value\
\
After you call `solver.solve()` and OR-Tools finds a solution, you can retrieve the final, optimal value of the objective function using the `value()` method on the `MPObjective` object.\
\
Looking back at the solution printing section of `BasicExample.java`:\
\
```java\
// [START print_solution]\
// ... after calling solver.solve() and checking resultStatus ...\
\
System.out.println("Solution:");\
System.out.println("Objective value = " + objective.value()); // Get the optimal objective value\
System.out.println("x = " + x.solutionValue());\
System.out.println("y = " + y.solutionValue());\
// [END print_solution]\
```\
\
`objective.value()` returns the numerical result of evaluating the objective expression (`3*x + 1*y`) using the optimal values that the solver found for `x` and `y`. In our example, the solver found `x=1.0` and `y=1.0`. Plugging these into the objective: `3*(1.0) + 1*(1.0) = 3.0 + 1.0 = 4.0`. So, `objective.value()` returns 4.0.\
\
## MPObjective Under the Hood (Simple View)\
\
Like `MPVariable` and `MPConstraint`, the `MPObjective` object in Java is a handle to an internal representation managed by the OR-Tools native code.\
\
When you get the `MPObjective` via `solver.objective()`, you're getting a Java object that references the single objective structure within the native solver instance.\
\
```mermaid\
sequenceDiagram\
    participant YourJavaApp\
    participant MPSolverJavaObj["MPSolver Object (Java)"]\
    participant MPObjectiveJavaObj["MPObjective Object (Java)"]\
    participant OrToolsNativeCode["OR-Tools Native Code (C++)"]\
    participant MPVariableJavaObjX["MPVariable 'x' (Java)"]\
    participant MPVariableJavaObjY["MPVariable 'y' (Java)"]\
\
    YourJavaApp->>MPSolverJavaObj: solver.objective()\
    MPSolverJavaObj->>OrToolsNativeCode: Request handle to the objective structure\
    Note over OrToolsNativeCode: Assumes objective structure was<br/>created when solver was created.\
    OrToolsNativeCode-->>MPSolverJavaObj: Return internal ID/pointer for the objective\
    MPSolverJavaObj->>MPObjectiveJavaObj: Create MPObjective Java object,<br/>store the internal ID\
    MPObjectiveJavaObj-->>YourJavaApp: Return MPObjective Java object (assigned to 'objective')\
\
    YourJavaApp->>MPObjectiveJavaObj: objective.setCoefficient(x, 3)\
    MPObjectiveJavaObj->>MPVariableJavaObjX: Get internal ID for 'x'\
    MPVariableJavaObjX-->>MPObjectiveJavaObj: Return internal ID of 'x'\
    MPObjectiveJavaObj->>OrToolsNativeCode: Tell objective (using its ID):<br/>Add variable with ID of 'x' and coefficient 3.0\
    Note over OrToolsNativeCode: Updates internal objective structure.\
\
    YourJavaApp->>MPObjectiveJavaObj: objective.setCoefficient(y, 1)\
    MPObjectiveJavaObj->>MPVariableJavaObjY: Get internal ID for 'y'\
    MPVariableJavaObjY-->>MPObjectiveJavaObj: Return internal ID of 'y'\
    MPObjectiveJavaObj->>OrToolsNativeCode: Tell objective (using its ID):<br/>Add variable with ID of 'y' and coefficient 1.0\
    Note over OrToolsNativeCode: Updates internal objective structure.\
\
    YourJavaApp->>MPObjectiveJavaObj: objective.setMaximization()\
    MPObjectiveJavaObj->>OrToolsNativeCode: Tell objective (using its ID):<br/>Set goal to maximization.\
    Note over OrToolsNativeCode: Updates internal objective structure.\
\
    Note over OrToolsNativeCode: Objective now represents<br/>Maximize (3*x + 1*y).\
\
    Note over YourJavaApp: Later, after solver.solve()...\
\
    YourJavaApp->>MPObjectiveJavaObj: objective.value()\
    MPObjectiveJavaObj->>OrToolsNativeCode: Request the solved value<br/>of the objective function.\
    OrToolsNativeCode-->>MPObjectiveJavaObj: Return calculated value (e.g., 4.0)\
    MPObjectiveJavaObj-->>YourJavaApp: Return value\
```\
\
When you call `setCoefficient` or `setMaximization`/`setMinimization` on the Java `MPObjective` object, it uses its internal ID to communicate with the native OR-Tools code, telling it how to configure the objective function's internal representation.\
\
When `solver.solve()` runs, the solver algorithm works directly with this internal objective representation along with the variables and constraints to find the optimal solution. The resulting objective value is stored internally, and `objective.value()` retrieves this final calculated number.\
\
## Minimal Example: Maximize a Single Variable (Objective Part)\
\
Let's revisit our minimal example from the `MPSolver` chapter, focusing just on how the objective is set up.\
\
Problem: Maximize `x` subject to `0 <= x <= 5` and `x <= 2`.\
\
```java\
// Assuming solver and variable x are already created:\
// MPSolver solver = ...;\
// MPVariable x = solver.makeNumVar(0.0, 5.0, "x");\
// MPConstraint c1 = solver.makeConstraint(-MPSolver.infinity(), 2.0, "limit_x");\
// c1.setCoefficient(x, 1);\
\
// Get the objective object\
MPObjective objective = solver.objective();\
System.out.println("Objective object obtained.");\
\
// Define the objective expression: 1 * x\
objective.setCoefficient(x, 1); // We want to maximize x, which is 1*x\
System.out.println("Coefficient for x set in objective.");\
\
// Set the goal: Maximize\
objective.setMaximization();\
System.out.println("Objective set to maximization.");\
\
// Now the objective is ready for solver.solve();\
```\
\
In this simple case, the objective is just `x`. This is equivalent to `1 * x`. So, we add variable `x` to the objective with a coefficient of `1`. Then we specify that we want to `setMaximization()`.\
\
After solving, calling `objective.value()` would return the maximum value found for `x` (which is 2.0 in this problem).\
\
## Summary\
\
In this chapter, we completed the picture of defining a linear programming problem in OR-Tools by focusing on the `MPObjective`. We learned that it represents the function we want to maximize or minimize. We saw how to obtain the `MPObjective` object from the `MPSolver` using `solver.objective()`, how to define the linear expression using `setCoefficient()` with our `MPVariable`s, and how to specify the goal (maximization or minimization) using `setMaximization()` or `setMinimization()`. Finally, we learned how to retrieve the optimal objective value after solving using the `value()` method.\
\
With `MPSolver`, `MPVariable`, `MPConstraint`, and `MPObjective`, you now understand the core building blocks needed to model and solve linear programming problems using `ortools-java`.\
\
In the next chapter, we'll switch gears slightly to look at how the project uses **GitHub Actions** to automate the process of building and testing the code, ensuring everything works correctly whenever changes are made.\
\
[Chapter 7: GitHub Actions Workflow](07_github_actions_workflow_.md)\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/src/main/java/org/or_tools/example/BasicExample.java)</sup></sub>\
\
\
# Chapter 7: GitHub Actions Workflow\
\
Welcome back! In the previous chapters ([Chapter 3: MPSolver](03_mpsolver_.md), [Chapter 4: MPVariable](04_mpvariable_.md), [Chapter 5: MPConstraint](05_mpconstraint_.md), and [Chapter 6: MPObjective](06_mpobjective_.md)), we learned the core concepts of defining optimization problems using the `ortools-java` library. We also saw in [Chapter 2: Maven Build System](02_maven_build_system_.md) how Maven helps us manage dependencies, compile our code, and run the example.\
\
Now, imagine you've made some changes to the code. How do you know for sure that your changes didn't accidentally break something? How do you ensure that the example still builds and runs correctly, not just on your computer, but potentially on other operating systems like Windows, Linux, or macOS?\
\
Manually building and running the project on every possible environment each time you make a change is tedious and error-prone. This is where automation comes in!\
\
## The Need for Automated Quality Control\
\
Whenever code is changed in a software project, it's crucial to verify that the changes haven't introduced new errors or broken existing functionality. This is especially important for libraries or projects that need to work on different types of computers (like Windows, macOS, Linux) or in different environments (like inside a Docker container), as `ortools-java` does with its native libraries.\
\
Automated checks help maintain the quality and reliability of the project. They provide confidence that the project is always in a working state.\
\
## The Solution: GitHub Actions\
\
GitHub Actions is a service provided by GitHub that allows you to automate tasks directly within your code repository. It's commonly used for **Continuous Integration (CI)**, which is the practice of frequently integrating code changes and automatically verifying them with builds and tests.\
\
Think of GitHub Actions as a robotic assistant that lives inside your GitHub repository. You give this assistant a set of instructions, and it will automatically perform those tasks for you whenever certain events happen, like pushing new code or creating a pull request.\
\
For the `java_or-tools` project, GitHub Actions is configured to:\
\
1.  Detect when new code is pushed or a pull request is opened.\
2.  Automatically start up virtual computers on GitHub's servers.\
3.  On these virtual computers, perform tasks like:\
    *   Getting the latest code.\
    *   Checking if Java and Maven are installed.\
    *   Building the project using Maven (`mvn compile`).\
    *   Running the example code using Maven (`mvn exec:java`).\
    *   Packaging the application using Maven (`mvn package`).\
4.  Report back whether all these steps succeeded or failed.\
\
This automated process runs on different operating systems (Linux, Windows, macOS) and even inside a Docker environment, ensuring that the `java_or-tools` example works correctly across the various platforms where `ortools-java` is supported.\
\
## What is a GitHub Actions Workflow?\
\
A set of automated tasks in GitHub Actions is called a **workflow**. Workflows are defined in files written in **YAML** format. These files live in a special directory in your repository: `.github/workflows/`.\
\
The `java_or-tools` project has several YAML files in this directory, each defining a workflow to test the project on a specific environment:\
\
*   `amd64_linux.yml`: Tests on an AMD64 (standard PC/server) Linux environment.\
*   `amd64_windows.yml`: Tests on an AMD64 Windows environment.\
*   `amd64_macos.yml`: Tests on an AMD64 (Intel) macOS environment.\
*   `arm64_macos.yml`: Tests on an ARM64 (Apple Silicon) macOS environment.\
*   `amd64_docker.yml`: Tests building and running within a Docker container.\
\
Let's break down the key concepts within a workflow file.\
\
### Key Concepts in a Workflow\
\
*   **`name`**: A human-readable name for the workflow (e.g., `amd64 Linux`).\
*   **`on`**: This specifies the **events** that trigger the workflow. Common events are `push` (when code is pushed to the repository) and `pull_request` (when a pull request is created or updated). `workflow_dispatch` allows you to manually trigger the workflow from the GitHub website.\
*   **`jobs`**: A workflow is made up of one or more jobs. Jobs run in parallel by default, but can be configured to run sequentially. Each job is an independent set of steps.\
*   **`runs-on`**: This specifies the type of virtual machine (called a **runner**) that the job will run on. GitHub provides runners for different operating systems. Examples include `ubuntu-latest`, `windows-latest`, `macos-latest`, `macos-13` (for specific Intel macOS versions), or `macos-latest` (which might be ARM64).\
*   **`steps`**: A job consists of a sequence of steps. Each step is a single task, like running a command or executing an action. Steps are executed in order.\
*   **`uses`**: This keyword indicates that a step will use a pre-built **action** from the GitHub Actions Marketplace or from the same repository. Actions are reusable units of work. For example, `actions/checkout@v4` is a standard action that downloads your repository's code onto the runner.\
*   **`run`**: This keyword indicates that a step will execute a command in the shell on the runner machine. This is where we run our Maven commands!\
\
### Examining a Simple Workflow (`amd64_linux.yml`)\
\
Let's look at the structure of one of the workflow files, like `amd64_linux.yml`, piece by piece.\
\
```yaml\
# ref: https://github.com/actions/runner-images\
name: amd64 Linux\
\
on: [push, pull_request, workflow_dispatch]\
\
concurrency:\
  group: $\{\{github.workflow\}\}-$\{\{github.ref\}\}\
  cancel-in-progress: true\
\
# Building using the github runner environement directly.\
jobs:\
  native:\
    name: Linux\'95Java\
    runs-on: ubuntu-latest\
    steps:\
    # ... steps defined below ...\
```\
\
*   `name: amd64 Linux`: The name of this workflow.\
*   `on: [push, pull_request, workflow_dispatch]`: This workflow will run automatically whenever someone pushes code to the repository, creates or updates a pull request, or is manually triggered.\
*   `concurrency`: This section helps manage how workflows run, ensuring only one workflow for the same branch/pull request runs at a time, cancelling older ones. This isn't strictly necessary to understand for a beginner but is good practice.\
*   `jobs:`: This starts the definition of the jobs in this workflow.\
*   `native:`: This is the ID (and name, defaults to ID if `name` isn't specified here) of the first job in this workflow.\
*   `runs-on: ubuntu-latest`: This job will run on a virtual machine provided by GitHub that runs the latest version of Ubuntu Linux (on an AMD64 architecture).\
\
Now let's look at the `steps` within the `native` job:\
\
```yaml\
    steps:\
    - uses: actions/checkout@v4\
      name: Checkout code # Optional name for the step\
\
    - name: Check java\
      run: java -version\
\
    - name: Check maven\
      run: mvn --version\
\
    - name: Compile project\
      run: mvn compile\
\
    - name: Test project\
      run: mvn exec:java\
\
    - name: Package project\
      run: mvn package\
```\
\
*   `- uses: actions/checkout@v4`: This step uses the `checkout` action to download the code from the repository onto the `ubuntu-latest` runner machine. `@v4` specifies the version of the action to use. The `name: Checkout code` provides a clear label for this step in the GitHub Actions UI.\
*   `- name: Check java` and `run: java -version`: This step is named "Check java" and runs the command `java -version` in the shell on the runner. This verifies that Java is available, which is necessary for our project.\
*   `- name: Check maven` and `run: mvn --version`: Similar to the Java check, this step runs `mvn --version` to ensure Maven is installed and available.\
*   `- name: Compile project` and `run: mvn compile`: This is a crucial step. It runs the Maven `compile` command (as we learned in [Chapter 2: Maven Build System](02_maven_build_system_.md)). Maven will download dependencies (like `ortools-java`) and compile the Java code. If there are compilation errors, this step will fail, and the workflow will stop.\
*   `- name: Test project` and `run: mvn exec:java`: This step runs the Maven `exec:java` command (from [Chapter 2](02_maven_build_system_.md)) to execute the `BasicExample.java` code. This is where the OR-Tools solver is created, the problem is defined, and the solution is found and printed. If the example code fails to run or crashes, this step will fail.\
*   `- name: Package project` and `run: mvn package`: This step runs the Maven `package` command (from [Chapter 2](02_maven_build_system_.md)) to create the project's JAR file. This verifies that the project can be successfully packaged into a distributable artifact.\
\
Each of these steps is like one instruction given to the robotic assistant (the runner). If any step fails (e.g., `mvn compile` finds a syntax error, or `mvn exec:java` encounters a runtime problem), the entire job (and potentially the workflow) is marked as failed.\
\
The other workflow files (`amd64_windows.yml`, `amd64_macos.yml`, `arm64_macos.yml`) contain very similar jobs and steps, but they run on different `runs-on` runners. This allows the project to be automatically built and tested on Windows, and different macOS architectures, every time a change is made. The `amd64_docker.yml` workflow is slightly different, using `docker build` commands instead of direct `mvn` commands, but the goal is the same: verify the project builds, runs, and packages correctly within that environment.\
\
## How GitHub Actions Workflow Works (Simple View)\
\
Here's a simplified look at the process when you push code:\
\
```mermaid\
sequenceDiagram\
    participant You\
    participant YourComputer\
    participant GitHub\
    participant GitHubActions["GitHub Actions Service"]\
    participant GitHubRunner["GitHub Runner (Virtual Machine)"]\
    participant Maven["Maven on Runner"]\
    participant YourCode["Your Project Code"]\
\
    You->>YourComputer: Write/Change code\
    YourComputer->>GitHub: Push code to repository\
\
    GitHub->>GitHubActions: Notify: "Code pushed event received!"\
    GitHubActions->>GitHub: Find workflow files in .github/workflows/\
    GitHubActions->>GitHubActions: Identify jobs and runners needed (e.g., Ubuntu runner)\
    GitHubActions->>GitHubRunner: Start a new virtual machine (e.g., Ubuntu)\
\
    GitHubRunner->>GitHubActions: "Ready to run job 'native'!"\
    GitHubActions->>GitHubRunner: Send workflow steps instructions\
\
    GitHubRunner->>GitHub: Use actions/checkout@v4 to get code\
    GitHub-->>GitHubRunner: Provide YourCode\
\
    GitHubRunner->>Maven: Run "mvn compile"\
    Maven->>GitHubRunner: Output compile status\
    Note over GitHubRunner: If compile fails, stop job, report failure.\
\
    GitHubRunner->>Maven: Run "mvn exec:java"\
    Maven->>GitHubRunner: Output runtime results (solver output)\
    Note over GitHubRunner: If run fails, stop job, report failure.\
\
    GitHubRunner->>Maven: Run "mvn package"\
    Maven->>GitHubRunner: Output package status\
    Note over GitHubRunner: If package fails, stop job, report failure.\
\
    GitHubRunner-->>GitHubActions: Report final job status (Success/Failure)\
    GitHubActions-->>GitHub: Update repository UI with workflow status\
\
    GitHub->>You: Notify workflow status (e.g., via email or UI badge)\
```\
\
1.  You make changes on your computer and push them to your repository on GitHub.\
2.  GitHub detects the `push` event.\
3.  GitHub's Actions service looks for workflow files in the `.github/workflows/` directory.\
4.  For each workflow triggered by the `push` event, GitHub Actions identifies the jobs that need to run and the type of runner (virtual machine) required for each job.\
5.  GitHub Actions starts the necessary runners. These are fresh virtual machines pre-configured with common software like Java and Maven.\
6.  GitHub Actions sends the list of steps for a job to its assigned runner.\
7.  The runner executes each step in sequence. This includes using the `checkout` action to get your code, running shell commands (`java -version`, `mvn --version`), and executing the core build, test, and package commands using Maven, relying on the `ortools-java` dependency as configured in the `pom.xml`.\
8.  As steps complete, the runner reports their status. If any step fails, the job stops, and the failure is reported.\
9.  Once all steps in a job complete successfully or a step fails, the runner reports the job's final status back to GitHub Actions.\
10. GitHub Actions updates the status of the workflow in the GitHub repository's UI (usually visible on the "Actions" tab and potentially on pull requests).\
11. GitHub can notify you (e.g., by email) about the workflow's success or failure.\
\
This automated feedback loop gives developers quick confidence that their changes haven't broken the fundamental build and run process on multiple target environments.\
\
### Keeping Actions Updated with Dependabot\
\
You might have noticed the `.github/dependabot.yml` file in the project.\
\
```yaml\
# Keep GitHub Actions up to date with GitHub's Dependabot...\
# https://docs.github.com/en/code-security/dependabot/working-with-dependabot/keeping-your-actions-up-to-date-with-dependabot\
# https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#package-ecosystem\
version: 2\
updates:\
  - package-ecosystem: github-actions # Look for updates to GitHub Actions\
    directory: / # Look in the root directory for workflows (.github/workflows)\
    groups:\
      github-actions:\
        patterns:\
          - "*"  # Group all Actions updates into a single larger pull request\
    schedule:\
      interval: weekly # Check for updates weekly\
```\
\
Dependabot is another GitHub feature that automatically checks for outdated dependencies. This configuration tells Dependabot to check for updates to the **GitHub Actions** used in the workflow files (like `actions/checkout@v4`) and automatically create pull requests to update them. This helps keep the CI workflows using the latest, most secure, and stable versions of the actions.\
\
## Summary\
\
In this chapter, we stepped away from the specifics of `ortools-java` modeling to understand how the `java_or-tools` project uses **GitHub Actions Workflows** for automated quality control. We learned that workflow files (written in YAML in `.github/workflows/`) define automated jobs that run on virtual machines called runners whenever events like code pushes occur. These jobs consist of steps that execute commands (like our familiar Maven commands) to build, run, and test the project on different operating systems. This automation ensures that the project is always buildable and the example code works across the various environments where `ortools-java` is used, providing a vital safety net for development. We also briefly saw how Dependabot helps keep these workflows themselves up to date.\
\
This chapter concludes our beginner-friendly tutorial series on the `java_or-tools` project and the core concepts of using Google OR-Tools in Java. You've learned how OR-Tools helps solve optimization problems, how Maven builds and manages the project, and the roles of `MPSolver`, `MPVariable`, `MPConstraint`, and `MPObjective` in defining a problem. Finally, you've seen how automated workflows ensure the project's reliability.\
\
You now have a solid foundation to explore more complex optimization problems and dive deeper into the capabilities of Google OR-Tools!\
\
Thank you for following along with this tutorial!\
\
---\
\
<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/dependabot.yml), [[2]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/workflows/amd64_docker.yml), [[3]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/workflows/amd64_linux.yml), [[4]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/workflows/amd64_macos.yml), [[5]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/workflows/amd64_windows.yml), [[6]](https://github.com/or-tools/java_or-tools/blob/1b0f325dfb6ff941b20a4e6d7a0b59f8d0f4b1e4/.github/workflows/arm64_macos.yml)</sup></sub>}